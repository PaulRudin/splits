#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Mar  9 17:55:36 2011 by generateDS.py version 2.4b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class TrainingCenterDatabase_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Folders=None, Activities=None, Workouts=None, Courses=None, Author=None, Extensions=None):
        self.Folders = Folders
        self.Activities = Activities
        self.Workouts = Workouts
        self.Courses = Courses
        self.Author = Author
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if TrainingCenterDatabase_t.subclass:
            return TrainingCenterDatabase_t.subclass(*args_, **kwargs_)
        else:
            return TrainingCenterDatabase_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Folders(self): return self.Folders
    def set_Folders(self, Folders): self.Folders = Folders
    def get_Activities(self): return self.Activities
    def set_Activities(self, Activities): self.Activities = Activities
    def get_Workouts(self): return self.Workouts
    def set_Workouts(self, Workouts): self.Workouts = Workouts
    def get_Courses(self): return self.Courses
    def set_Courses(self, Courses): self.Courses = Courses
    def get_Author(self): return self.Author
    def set_Author(self, Author): self.Author = Author
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='TrainingCenterDatabase_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TrainingCenterDatabase_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='TrainingCenterDatabase_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='TrainingCenterDatabase_t'):
        if self.Folders:
            self.Folders.export(outfile, level, namespace_, name_='Folders')
        if self.Activities:
            self.Activities.export(outfile, level, namespace_, name_='Activities')
        if self.Workouts:
            self.Workouts.export(outfile, level, namespace_, name_='Workouts')
        if self.Courses:
            self.Courses.export(outfile, level, namespace_, name_='Courses')
        #pr
        self.Author.export(outfile, level, namespace_, name_='Author')
        #Author_.export(outfile, level, namespace_, name_='Author')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Folders is not None or
            self.Activities is not None or
            self.Workouts is not None or
            self.Courses is not None or
            self.Author is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TrainingCenterDatabase_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Folders is not None:
            showIndent(outfile, level)
            outfile.write('Folders=model_.Folders_t(\n')
            self.Folders.exportLiteral(outfile, level, name_='Folders')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Activities is not None:
            showIndent(outfile, level)
            outfile.write('Activities=model_.ActivityList_t(\n')
            self.Activities.exportLiteral(outfile, level, name_='Activities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Workouts is not None:
            showIndent(outfile, level)
            outfile.write('Workouts=model_.WorkoutList_t(\n')
            self.Workouts.exportLiteral(outfile, level, name_='Workouts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Courses is not None:
            showIndent(outfile, level)
            outfile.write('Courses=model_.CourseList_t(\n')
            self.Courses.exportLiteral(outfile, level, name_='Courses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractSource_t is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSource_t=model_.AbstractSource_t(\n')
            self.AbstractSource_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Folders': 
            obj_ = Folders_t.factory()
            obj_.build(child_)
            self.set_Folders(obj_)
        elif nodeName_ == 'Activities': 
            obj_ = ActivityList_t.factory()
            obj_.build(child_)
            self.set_Activities(obj_)
        elif nodeName_ == 'Workouts': 
            obj_ = WorkoutList_t.factory()
            obj_.build(child_)
            self.set_Workouts(obj_)
        elif nodeName_ == 'Courses': 
            obj_ = CourseList_t.factory()
            obj_.build(child_)
            self.set_Courses(obj_)
        elif nodeName_ == 'Author': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Author> element')
            self.set_Author(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class TrainingCenterDatabase_t


class Folders_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, History=None, Workouts=None, Courses=None):
        self.History = History
        self.Workouts = Workouts
        self.Courses = Courses
    def factory(*args_, **kwargs_):
        if Folders_t.subclass:
            return Folders_t.subclass(*args_, **kwargs_)
        else:
            return Folders_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_History(self): return self.History
    def set_History(self, History): self.History = History
    def get_Workouts(self): return self.Workouts
    def set_Workouts(self, Workouts): self.Workouts = Workouts
    def get_Courses(self): return self.Courses
    def set_Courses(self, Courses): self.Courses = Courses
    def export(self, outfile, level, namespace_='tc2:', name_='Folders_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Folders_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Folders_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Folders_t'):
        if self.History:
            self.History.export(outfile, level, namespace_, name_='History')
        if self.Workouts:
            self.Workouts.export(outfile, level, namespace_, name_='Workouts')
        if self.Courses:
            self.Courses.export(outfile, level, namespace_, name_='Courses')
    def hasContent_(self):
        if (
            self.History is not None or
            self.Workouts is not None or
            self.Courses is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Folders_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.History is not None:
            showIndent(outfile, level)
            outfile.write('History=model_.History_t(\n')
            self.History.exportLiteral(outfile, level, name_='History')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Workouts is not None:
            showIndent(outfile, level)
            outfile.write('Workouts=model_.Workouts_t(\n')
            self.Workouts.exportLiteral(outfile, level, name_='Workouts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Courses is not None:
            showIndent(outfile, level)
            outfile.write('Courses=model_.Courses_t(\n')
            self.Courses.exportLiteral(outfile, level, name_='Courses')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'History': 
            obj_ = History_t.factory()
            obj_.build(child_)
            self.set_History(obj_)
        elif nodeName_ == 'Workouts': 
            obj_ = Workouts_t.factory()
            obj_.build(child_)
            self.set_Workouts(obj_)
        elif nodeName_ == 'Courses': 
            obj_ = Courses_t.factory()
            obj_.build(child_)
            self.set_Courses(obj_)
# end class Folders_t


class ActivityList_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Activity=None, MultiSportSession=None):
        if Activity is None:
            self.Activity = []
        else:
            self.Activity = Activity
        if MultiSportSession is None:
            self.MultiSportSession = []
        else:
            self.MultiSportSession = MultiSportSession
    def factory(*args_, **kwargs_):
        if ActivityList_t.subclass:
            return ActivityList_t.subclass(*args_, **kwargs_)
        else:
            return ActivityList_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def add_Activity(self, value): self.Activity.append(value)
    def insert_Activity(self, index, value): self.Activity[index] = value
    def get_MultiSportSession(self): return self.MultiSportSession
    def set_MultiSportSession(self, MultiSportSession): self.MultiSportSession = MultiSportSession
    def add_MultiSportSession(self, value): self.MultiSportSession.append(value)
    def insert_MultiSportSession(self, index, value): self.MultiSportSession[index] = value
    def export(self, outfile, level, namespace_='tc2:', name_='ActivityList_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ActivityList_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='ActivityList_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='ActivityList_t'):
        for Activity_ in self.Activity:
            Activity_.export(outfile, level, namespace_, name_='Activity')
        for MultiSportSession_ in self.MultiSportSession:
            MultiSportSession_.export(outfile, level, namespace_, name_='MultiSportSession')
    def hasContent_(self):
        if (
            self.Activity or
            self.MultiSportSession
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActivityList_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Activity=[\n')
        level += 1
        for Activity_ in self.Activity:
            showIndent(outfile, level)
            outfile.write('model_.Activity_t(\n')
            Activity_.exportLiteral(outfile, level, name_='Activity_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MultiSportSession=[\n')
        level += 1
        for MultiSportSession_ in self.MultiSportSession:
            showIndent(outfile, level)
            outfile.write('model_.MultiSportSession_t(\n')
            MultiSportSession_.exportLiteral(outfile, level, name_='MultiSportSession_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Activity': 
            obj_ = Activity_t.factory()
            obj_.build(child_)
            self.Activity.append(obj_)
        elif nodeName_ == 'MultiSportSession': 
            obj_ = MultiSportSession_t.factory()
            obj_.build(child_)
            self.MultiSportSession.append(obj_)
# end class ActivityList_t


class WorkoutList_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Workout=None):
        if Workout is None:
            self.Workout = []
        else:
            self.Workout = Workout
    def factory(*args_, **kwargs_):
        if WorkoutList_t.subclass:
            return WorkoutList_t.subclass(*args_, **kwargs_)
        else:
            return WorkoutList_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Workout(self): return self.Workout
    def set_Workout(self, Workout): self.Workout = Workout
    def add_Workout(self, value): self.Workout.append(value)
    def insert_Workout(self, index, value): self.Workout[index] = value
    def export(self, outfile, level, namespace_='tc2:', name_='WorkoutList_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='WorkoutList_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='WorkoutList_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='WorkoutList_t'):
        for Workout_ in self.Workout:
            Workout_.export(outfile, level, namespace_, name_='Workout')
    def hasContent_(self):
        if (
            self.Workout
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WorkoutList_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Workout=[\n')
        level += 1
        for Workout_ in self.Workout:
            showIndent(outfile, level)
            outfile.write('model_.Workout_t(\n')
            Workout_.exportLiteral(outfile, level, name_='Workout_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Workout': 
            obj_ = Workout_t.factory()
            obj_.build(child_)
            self.Workout.append(obj_)
# end class WorkoutList_t


class CourseList_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Course=None):
        if Course is None:
            self.Course = []
        else:
            self.Course = Course
    def factory(*args_, **kwargs_):
        if CourseList_t.subclass:
            return CourseList_t.subclass(*args_, **kwargs_)
        else:
            return CourseList_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Course(self): return self.Course
    def set_Course(self, Course): self.Course = Course
    def add_Course(self, value): self.Course.append(value)
    def insert_Course(self, index, value): self.Course[index] = value
    def export(self, outfile, level, namespace_='tc2:', name_='CourseList_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CourseList_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CourseList_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CourseList_t'):
        for Course_ in self.Course:
            Course_.export(outfile, level, namespace_, name_='Course')
    def hasContent_(self):
        if (
            self.Course
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseList_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Course=[\n')
        level += 1
        for Course_ in self.Course:
            showIndent(outfile, level)
            outfile.write('model_.Course_t(\n')
            Course_.exportLiteral(outfile, level, name_='Course_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Course': 
            obj_ = Course_t.factory()
            obj_.build(child_)
            self.Course.append(obj_)
# end class CourseList_t


class History_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Running=None, Biking=None, Other=None, MultiSport=None, Extensions=None):
        self.Running = Running
        self.Biking = Biking
        self.Other = Other
        self.MultiSport = MultiSport
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if History_t.subclass:
            return History_t.subclass(*args_, **kwargs_)
        else:
            return History_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Running(self): return self.Running
    def set_Running(self, Running): self.Running = Running
    def get_Biking(self): return self.Biking
    def set_Biking(self, Biking): self.Biking = Biking
    def get_Other(self): return self.Other
    def set_Other(self, Other): self.Other = Other
    def get_MultiSport(self): return self.MultiSport
    def set_MultiSport(self, MultiSport): self.MultiSport = MultiSport
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='History_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='History_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='History_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='History_t'):
        if self.Running:
            self.Running.export(outfile, level, namespace_, name_='Running', )
        if self.Biking:
            self.Biking.export(outfile, level, namespace_, name_='Biking', )
        if self.Other:
            self.Other.export(outfile, level, namespace_, name_='Other', )
        if self.MultiSport:
            self.MultiSport.export(outfile, level, namespace_, name_='MultiSport', )
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Running is not None or
            self.Biking is not None or
            self.Other is not None or
            self.MultiSport is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='History_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Running is not None:
            showIndent(outfile, level)
            outfile.write('Running=model_.HistoryFolder_t(\n')
            self.Running.exportLiteral(outfile, level, name_='Running')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Biking is not None:
            showIndent(outfile, level)
            outfile.write('Biking=model_.HistoryFolder_t(\n')
            self.Biking.exportLiteral(outfile, level, name_='Biking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Other is not None:
            showIndent(outfile, level)
            outfile.write('Other=model_.HistoryFolder_t(\n')
            self.Other.exportLiteral(outfile, level, name_='Other')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MultiSport is not None:
            showIndent(outfile, level)
            outfile.write('MultiSport=model_.MultiSportFolder_t(\n')
            self.MultiSport.exportLiteral(outfile, level, name_='MultiSport')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Running': 
            obj_ = HistoryFolder_t.factory()
            obj_.build(child_)
            self.set_Running(obj_)
        elif nodeName_ == 'Biking': 
            obj_ = HistoryFolder_t.factory()
            obj_.build(child_)
            self.set_Biking(obj_)
        elif nodeName_ == 'Other': 
            obj_ = HistoryFolder_t.factory()
            obj_.build(child_)
            self.set_Other(obj_)
        elif nodeName_ == 'MultiSport': 
            obj_ = MultiSportFolder_t.factory()
            obj_.build(child_)
            self.set_MultiSport(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class History_t


class ActivityReference_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.Id = Id
    def factory(*args_, **kwargs_):
        if ActivityReference_t.subclass:
            return ActivityReference_t.subclass(*args_, **kwargs_)
        else:
            return ActivityReference_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='tc2:', name_='ActivityReference_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ActivityReference_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='ActivityReference_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='ActivityReference_t'):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('<%sId>%s</%sId>\n' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_))
    def hasContent_(self):
        if (
            self.Id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActivityReference_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
# end class ActivityReference_t


class HistoryFolder_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Folder=None, ActivityRef=None, Week=None, Notes=None, Extensions=None):
        self.Name = _cast(None, Name)
        if Folder is None:
            self.Folder = []
        else:
            self.Folder = Folder
        if ActivityRef is None:
            self.ActivityRef = []
        else:
            self.ActivityRef = ActivityRef
        if Week is None:
            self.Week = []
        else:
            self.Week = Week
        self.Notes = Notes
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if HistoryFolder_t.subclass:
            return HistoryFolder_t.subclass(*args_, **kwargs_)
        else:
            return HistoryFolder_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Folder(self): return self.Folder
    def set_Folder(self, Folder): self.Folder = Folder
    def add_Folder(self, value): self.Folder.append(value)
    def insert_Folder(self, index, value): self.Folder[index] = value
    def get_ActivityRef(self): return self.ActivityRef
    def set_ActivityRef(self, ActivityRef): self.ActivityRef = ActivityRef
    def add_ActivityRef(self, value): self.ActivityRef.append(value)
    def insert_ActivityRef(self, index, value): self.ActivityRef[index] = value
    def get_Week(self): return self.Week
    def set_Week(self, Week): self.Week = Week
    def add_Week(self, value): self.Week.append(value)
    def insert_Week(self, index, value): self.Week[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='tc2:', name_='HistoryFolder_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HistoryFolder_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HistoryFolder_t'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HistoryFolder_t'):
        for Folder_ in self.Folder:
            Folder_.export(outfile, level, namespace_, name_='Folder')
        for ActivityRef_ in self.ActivityRef:
            ActivityRef_.export(outfile, level, namespace_, name_='ActivityRef')
        for Week_ in self.Week:
            Week_.export(outfile, level, namespace_, name_='Week')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Folder or
            self.ActivityRef or
            self.Week or
            self.Notes is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HistoryFolder_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Folder=[\n')
        level += 1
        for Folder_ in self.Folder:
            showIndent(outfile, level)
            outfile.write('model_.HistoryFolder_t(\n')
            Folder_.exportLiteral(outfile, level, name_='HistoryFolder_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActivityRef=[\n')
        level += 1
        for ActivityRef_ in self.ActivityRef:
            showIndent(outfile, level)
            outfile.write('model_.ActivityReference_t(\n')
            ActivityRef_.exportLiteral(outfile, level, name_='ActivityReference_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Week=[\n')
        level += 1
        for Week_ in self.Week:
            showIndent(outfile, level)
            outfile.write('model_.Week_t(\n')
            Week_.exportLiteral(outfile, level, name_='Week_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Folder': 
            obj_ = HistoryFolder_t.factory()
            obj_.build(child_)
            self.Folder.append(obj_)
        elif nodeName_ == 'ActivityRef': 
            obj_ = ActivityReference_t.factory()
            obj_.build(child_)
            self.ActivityRef.append(obj_)
        elif nodeName_ == 'Week': 
            obj_ = Week_t.factory()
            obj_.build(child_)
            self.Week.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class HistoryFolder_t


class MultiSportFolder_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Folder=None, MultisportActivityRef=None, Week=None, Notes=None, Extensions=None):
        self.Name = _cast(None, Name)
        if Folder is None:
            self.Folder = []
        else:
            self.Folder = Folder
        if MultisportActivityRef is None:
            self.MultisportActivityRef = []
        else:
            self.MultisportActivityRef = MultisportActivityRef
        if Week is None:
            self.Week = []
        else:
            self.Week = Week
        self.Notes = Notes
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if MultiSportFolder_t.subclass:
            return MultiSportFolder_t.subclass(*args_, **kwargs_)
        else:
            return MultiSportFolder_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Folder(self): return self.Folder
    def set_Folder(self, Folder): self.Folder = Folder
    def add_Folder(self, value): self.Folder.append(value)
    def insert_Folder(self, index, value): self.Folder[index] = value
    def get_MultisportActivityRef(self): return self.MultisportActivityRef
    def set_MultisportActivityRef(self, MultisportActivityRef): self.MultisportActivityRef = MultisportActivityRef
    def add_MultisportActivityRef(self, value): self.MultisportActivityRef.append(value)
    def insert_MultisportActivityRef(self, index, value): self.MultisportActivityRef[index] = value
    def get_Week(self): return self.Week
    def set_Week(self, Week): self.Week = Week
    def add_Week(self, value): self.Week.append(value)
    def insert_Week(self, index, value): self.Week[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='tc2:', name_='MultiSportFolder_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='MultiSportFolder_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='MultiSportFolder_t'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='MultiSportFolder_t'):
        for Folder_ in self.Folder:
            Folder_.export(outfile, level, namespace_, name_='Folder')
        for MultisportActivityRef_ in self.MultisportActivityRef:
            MultisportActivityRef_.export(outfile, level, namespace_, name_='MultisportActivityRef')
        for Week_ in self.Week:
            Week_.export(outfile, level, namespace_, name_='Week')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Folder or
            self.MultisportActivityRef or
            self.Week or
            self.Notes is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSportFolder_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Folder=[\n')
        level += 1
        for Folder_ in self.Folder:
            showIndent(outfile, level)
            outfile.write('model_.MultiSportFolder_t(\n')
            Folder_.exportLiteral(outfile, level, name_='MultiSportFolder_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MultisportActivityRef=[\n')
        level += 1
        for MultisportActivityRef_ in self.MultisportActivityRef:
            showIndent(outfile, level)
            outfile.write('model_.ActivityReference_t(\n')
            MultisportActivityRef_.exportLiteral(outfile, level, name_='ActivityReference_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Week=[\n')
        level += 1
        for Week_ in self.Week:
            showIndent(outfile, level)
            outfile.write('model_.Week_t(\n')
            Week_.exportLiteral(outfile, level, name_='Week_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Folder': 
            obj_ = MultiSportFolder_t.factory()
            obj_.build(child_)
            self.Folder.append(obj_)
        elif nodeName_ == 'MultisportActivityRef': 
            obj_ = ActivityReference_t.factory()
            obj_.build(child_)
            self.MultisportActivityRef.append(obj_)
        elif nodeName_ == 'Week': 
            obj_ = Week_t.factory()
            obj_.build(child_)
            self.Week.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class MultiSportFolder_t


class Week_t(GeneratedsSuper):
    """The week is written out only if the notes are present."""
    subclass = None
    superclass = None
    def __init__(self, StartDay=None, Notes=None):
        self.StartDay = _cast(None, StartDay)
        self.Notes = Notes
    def factory(*args_, **kwargs_):
        if Week_t.subclass:
            return Week_t.subclass(*args_, **kwargs_)
        else:
            return Week_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_StartDay(self): return self.StartDay
    def set_StartDay(self, StartDay): self.StartDay = StartDay
    def export(self, outfile, level, namespace_='tc2:', name_='Week_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Week_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Week_t'):
        if self.StartDay is not None and 'StartDay' not in already_processed:
            already_processed.append('StartDay')
            outfile.write(' StartDay=%s' % (self.gds_format_string(quote_attrib(self.StartDay).encode(ExternalEncoding), input_name='StartDay'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Week_t'):
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
    def hasContent_(self):
        if (
            self.Notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Week_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StartDay is not None and 'StartDay' not in already_processed:
            already_processed.append('StartDay')
            showIndent(outfile, level)
            outfile.write('StartDay = "%s",\n' % (self.StartDay,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('StartDay')
        if value is not None and 'StartDay' not in already_processed:
            already_processed.append('StartDay')
            self.StartDay = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
# end class Week_t


class MultiSportSession_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, FirstSport=None, NextSport=None, Notes=None):
        self.Id = Id
        self.FirstSport = FirstSport
        if NextSport is None:
            self.NextSport = []
        else:
            self.NextSport = NextSport
        self.Notes = Notes
    def factory(*args_, **kwargs_):
        if MultiSportSession_t.subclass:
            return MultiSportSession_t.subclass(*args_, **kwargs_)
        else:
            return MultiSportSession_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_FirstSport(self): return self.FirstSport
    def set_FirstSport(self, FirstSport): self.FirstSport = FirstSport
    def get_NextSport(self): return self.NextSport
    def set_NextSport(self, NextSport): self.NextSport = NextSport
    def add_NextSport(self, value): self.NextSport.append(value)
    def insert_NextSport(self, index, value): self.NextSport[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def export(self, outfile, level, namespace_='tc2:', name_='MultiSportSession_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='MultiSportSession_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='MultiSportSession_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='MultiSportSession_t'):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('<%sId>%s</%sId>\n' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_))
        if self.FirstSport:
            self.FirstSport.export(outfile, level, namespace_, name_='FirstSport', )
        for NextSport_ in self.NextSport:
            NextSport_.export(outfile, level, namespace_, name_='NextSport')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
    def hasContent_(self):
        if (
            self.Id is not None or
            self.FirstSport is not None or
            self.NextSport or
            self.Notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MultiSportSession_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.FirstSport is not None:
            showIndent(outfile, level)
            outfile.write('FirstSport=model_.FirstSport_t(\n')
            self.FirstSport.exportLiteral(outfile, level, name_='FirstSport')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('NextSport=[\n')
        level += 1
        for NextSport_ in self.NextSport:
            showIndent(outfile, level)
            outfile.write('model_.NextSport_t(\n')
            NextSport_.exportLiteral(outfile, level, name_='NextSport_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'FirstSport': 
            obj_ = FirstSport_t.factory()
            obj_.build(child_)
            self.set_FirstSport(obj_)
        elif nodeName_ == 'NextSport': 
            obj_ = NextSport_t.factory()
            obj_.build(child_)
            self.NextSport.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
# end class MultiSportSession_t


class FirstSport_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Activity=None):
        self.Activity = Activity
    def factory(*args_, **kwargs_):
        if FirstSport_t.subclass:
            return FirstSport_t.subclass(*args_, **kwargs_)
        else:
            return FirstSport_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def export(self, outfile, level, namespace_='tc2:', name_='FirstSport_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='FirstSport_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='FirstSport_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='FirstSport_t'):
        if self.Activity:
            self.Activity.export(outfile, level, namespace_, name_='Activity', )
    def hasContent_(self):
        if (
            self.Activity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirstSport_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Activity is not None:
            showIndent(outfile, level)
            outfile.write('Activity=model_.Activity_t(\n')
            self.Activity.exportLiteral(outfile, level, name_='Activity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Activity': 
            obj_ = Activity_t.factory()
            obj_.build(child_)
            self.set_Activity(obj_)
# end class FirstSport_t


class NextSport_t(GeneratedsSuper):
    """Each sport contains an optional transition and a run."""
    subclass = None
    superclass = None
    def __init__(self, Transition=None, Activity=None):
        self.Transition = Transition
        self.Activity = Activity
    def factory(*args_, **kwargs_):
        if NextSport_t.subclass:
            return NextSport_t.subclass(*args_, **kwargs_)
        else:
            return NextSport_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def export(self, outfile, level, namespace_='tc2:', name_='NextSport_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='NextSport_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='NextSport_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='NextSport_t'):
        if self.Transition:
            self.Transition.export(outfile, level, namespace_, name_='Transition')
        if self.Activity:
            self.Activity.export(outfile, level, namespace_, name_='Activity', )
    def hasContent_(self):
        if (
            self.Transition is not None or
            self.Activity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NextSport_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Transition is not None:
            showIndent(outfile, level)
            outfile.write('Transition=model_.ActivityLap_t(\n')
            self.Transition.exportLiteral(outfile, level, name_='Transition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Activity is not None:
            showIndent(outfile, level)
            outfile.write('Activity=model_.Activity_t(\n')
            self.Activity.exportLiteral(outfile, level, name_='Activity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Transition': 
            obj_ = ActivityLap_t.factory()
            obj_.build(child_)
            self.set_Transition(obj_)
        elif nodeName_ == 'Activity': 
            obj_ = Activity_t.factory()
            obj_.build(child_)
            self.set_Activity(obj_)
# end class NextSport_t


class Activity_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Sport=None, Id=None, Lap=None, Notes=None, Training=None, Creator=None, Extensions=None):
        self.Sport = _cast(None, Sport)
        self.Id = Id
        if Lap is None:
            self.Lap = []
        else:
            self.Lap = Lap
        self.Notes = Notes
        self.Training = Training
        self.Creator = Creator
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Activity_t.subclass:
            return Activity_t.subclass(*args_, **kwargs_)
        else:
            return Activity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Lap(self): return self.Lap
    def set_Lap(self, Lap): self.Lap = Lap
    def add_Lap(self, value): self.Lap.append(value)
    def insert_Lap(self, index, value): self.Lap[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Training(self): return self.Training
    def set_Training(self, Training): self.Training = Training
    def get_Creator(self): return self.Creator
    def set_Creator(self, Creator): self.Creator = Creator
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Sport(self): return self.Sport
    def set_Sport(self, Sport): self.Sport = Sport
    def validate_Sport_t(self, value):
        # Validate type Sport_t, a restriction on Token_t.
        pass
    def export(self, outfile, level, namespace_='tc2:', name_='Activity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Activity_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Activity_t'):
        if self.Sport is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            outfile.write(' Sport=%s' % (quote_attrib(self.Sport), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Activity_t'):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('<%sId>%s</%sId>\n' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_))
        for Lap_ in self.Lap:
            Lap_.export(outfile, level, namespace_, name_='Lap')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Training:
            self.Training.export(outfile, level, namespace_, name_='Training')
        #pr
        self.Creator.export(outfile, level, namespace_, name_='Creator')
        #Creator_.export(outfile, level, namespace_, name_='Creator')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Lap or
            self.Notes is not None or
            self.Training is not None or
            self.Creator is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Activity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Sport is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            showIndent(outfile, level)
            outfile.write('Sport = "%s",\n' % (self.Sport,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Lap=[\n')
        level += 1
        for Lap_ in self.Lap:
            showIndent(outfile, level)
            outfile.write('model_.ActivityLap_t(\n')
            Lap_.exportLiteral(outfile, level, name_='ActivityLap_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Training is not None:
            showIndent(outfile, level)
            outfile.write('Training=model_.Training_t(\n')
            self.Training.exportLiteral(outfile, level, name_='Training')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbstractSource_t is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSource_t=model_.AbstractSource_t(\n')
            self.AbstractSource_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Sport')
        if value is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            self.Sport = value
            self.validate_Sport_t(self.Sport)    # validate type Sport_t
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Lap': 
            obj_ = ActivityLap_t.factory()
            obj_.build(child_)
            self.Lap.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Training': 
            obj_ = Training_t.factory()
            obj_.build(child_)
            self.set_Training(obj_)
        elif nodeName_ == 'Creator': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Creator> element')
            self.set_Creator(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Activity_t


class AbstractSource_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None):
        self.Name = Name
    def factory(*args_, **kwargs_):
        if AbstractSource_t.subclass:
            return AbstractSource_t.subclass(*args_, **kwargs_)
        else:
            return AbstractSource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='tc2:', name_='AbstractSource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='AbstractSource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='AbstractSource_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='AbstractSource_t'):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractSource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class AbstractSource_t


class Device_t(AbstractSource_t):
    """Identifies the originating GPS device that tracked a run or used to
    identify the type of device capable of handling the data for
    loading."""
    subclass = None
    superclass = AbstractSource_t
    def __init__(self, Name=None, UnitId=None, ProductID=None, Version=None):
        super(Device_t, self).__init__(Name, )
        self.UnitId = UnitId
        self.ProductID = ProductID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if Device_t.subclass:
            return Device_t.subclass(*args_, **kwargs_)
        else:
            return Device_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitId(self): return self.UnitId
    def set_UnitId(self, UnitId): self.UnitId = UnitId
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def export(self, outfile, level, namespace_='tc2:', name_='Device_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Device_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Device_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Device_t'):
        super(Device_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Device_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Device_t'):
        super(Device_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.UnitId is not None:
            showIndent(outfile, level)
            outfile.write('<%sUnitId>%s</%sUnitId>\n' % (namespace_, self.gds_format_string(quote_xml(self.UnitId).encode(ExternalEncoding), input_name='UnitId'), namespace_))
        if self.ProductID is not None:
            showIndent(outfile, level)
            outfile.write('<%sProductID>%s</%sProductID>\n' % (namespace_, self.gds_format_string(quote_xml(self.ProductID).encode(ExternalEncoding), input_name='ProductID'), namespace_))
        if self.Version:
            self.Version.export(outfile, level, namespace_, name_='Version', )
    def hasContent_(self):
        if (
            self.UnitId is not None or
            self.ProductID is not None or
            self.Version is not None or
            super(Device_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Device_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Device_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Device_t, self).exportLiteralChildren(outfile, level, name_)
        if self.UnitId is not None:
            showIndent(outfile, level)
            outfile.write('UnitId=%s,\n' % quote_python(self.UnitId).encode(ExternalEncoding))
        if self.ProductID is not None:
            showIndent(outfile, level)
            outfile.write('ProductID=%s,\n' % quote_python(self.ProductID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.Version_t(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Device_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'UnitId':
            UnitId_ = child_.text
            UnitId_ = self.gds_validate_string(UnitId_, node, 'UnitId')
            self.UnitId = UnitId_
        elif nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID = ProductID_
        elif nodeName_ == 'Version': 
            obj_ = Version_t.factory()
            obj_.build(child_)
            self.set_Version(obj_)
        super(Device_t, self).buildChildren(child_, node, nodeName_, True)
# end class Device_t


class Application_t(AbstractSource_t):
    """Identifies a PC software application."""
    subclass = None
    superclass = AbstractSource_t
    def __init__(self, Name=None, Build=None, LangID=None, PartNumber=None):
        super(Application_t, self).__init__(Name, )
        self.Build = Build
        self.LangID = LangID
        self.PartNumber = PartNumber
    def factory(*args_, **kwargs_):
        if Application_t.subclass:
            return Application_t.subclass(*args_, **kwargs_)
        else:
            return Application_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Build(self): return self.Build
    def set_Build(self, Build): self.Build = Build
    def get_LangID(self): return self.LangID
    def set_LangID(self, LangID): self.LangID = LangID
    def get_PartNumber(self): return self.PartNumber
    def set_PartNumber(self, PartNumber): self.PartNumber = PartNumber
    def export(self, outfile, level, namespace_='tc2:', name_='Application_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Application_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Application_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Application_t'):
        super(Application_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Application_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Application_t'):
        super(Application_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Build:
            self.Build.export(outfile, level, namespace_, name_='Build', )
        if self.LangID is not None:
            showIndent(outfile, level)
            outfile.write('<%sLangID>%s</%sLangID>\n' % (namespace_, self.gds_format_string(quote_xml(self.LangID).encode(ExternalEncoding), input_name='LangID'), namespace_))
        if self.PartNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sPartNumber>%s</%sPartNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.PartNumber).encode(ExternalEncoding), input_name='PartNumber'), namespace_))
    def hasContent_(self):
        if (
            self.Build is not None or
            self.LangID is not None or
            self.PartNumber is not None or
            super(Application_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Application_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Application_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Application_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Build is not None:
            showIndent(outfile, level)
            outfile.write('Build=model_.Build_t(\n')
            self.Build.exportLiteral(outfile, level, name_='Build')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LangID is not None:
            showIndent(outfile, level)
            outfile.write('LangID=%s,\n' % quote_python(self.LangID).encode(ExternalEncoding))
        if self.PartNumber is not None:
            showIndent(outfile, level)
            outfile.write('PartNumber=%s,\n' % quote_python(self.PartNumber).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Application_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Build': 
            obj_ = Build_t.factory()
            obj_.build(child_)
            self.set_Build(obj_)
        elif nodeName_ == 'LangID':
            LangID_ = child_.text
            LangID_ = re_.sub(STRING_CLEANUP_PAT, " ", LangID_).strip()
            LangID_ = self.gds_validate_string(LangID_, node, 'LangID')
            self.LangID = LangID_
        elif nodeName_ == 'PartNumber':
            PartNumber_ = child_.text
            PartNumber_ = re_.sub(STRING_CLEANUP_PAT, " ", PartNumber_).strip()
            PartNumber_ = self.gds_validate_string(PartNumber_, node, 'PartNumber')
            self.PartNumber = PartNumber_
        super(Application_t, self).buildChildren(child_, node, nodeName_, True)
# end class Application_t


class Build_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Version=None, Type=None, Time=None, Builder=None):
        self.Version = Version
        self.Type = Type
        self.Time = Time
        self.Builder = Builder
    def factory(*args_, **kwargs_):
        if Build_t.subclass:
            return Build_t.subclass(*args_, **kwargs_)
        else:
            return Build_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Builder(self): return self.Builder
    def set_Builder(self, Builder): self.Builder = Builder
    def export(self, outfile, level, namespace_='tc2:', name_='Build_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Build_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Build_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Build_t'):
        if self.Version:
            self.Version.export(outfile, level, namespace_, name_='Version', )
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('<%sTime>%s</%sTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.Time).encode(ExternalEncoding), input_name='Time'), namespace_))
        if self.Builder is not None:
            showIndent(outfile, level)
            outfile.write('<%sBuilder>%s</%sBuilder>\n' % (namespace_, self.gds_format_string(quote_xml(self.Builder).encode(ExternalEncoding), input_name='Builder'), namespace_))
    def hasContent_(self):
        if (
            self.Version is not None or
            self.Type is not None or
            self.Time is not None or
            self.Builder is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Build_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.Version_t(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=%s,\n' % quote_python(self.Time).encode(ExternalEncoding))
        if self.Builder is not None:
            showIndent(outfile, level)
            outfile.write('Builder=%s,\n' % quote_python(self.Builder).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Version': 
            obj_ = Version_t.factory()
            obj_.build(child_)
            self.set_Version(obj_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = re_.sub(STRING_CLEANUP_PAT, " ", Type_).strip()
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = re_.sub(STRING_CLEANUP_PAT, " ", Time_).strip()
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
        elif nodeName_ == 'Builder':
            Builder_ = child_.text
            Builder_ = re_.sub(STRING_CLEANUP_PAT, " ", Builder_).strip()
            Builder_ = self.gds_validate_string(Builder_, node, 'Builder')
            self.Builder = Builder_
# end class Build_t


class Version_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VersionMajor=None, VersionMinor=None, BuildMajor=None, BuildMinor=None):
        self.VersionMajor = VersionMajor
        self.VersionMinor = VersionMinor
        self.BuildMajor = BuildMajor
        self.BuildMinor = BuildMinor
    def factory(*args_, **kwargs_):
        if Version_t.subclass:
            return Version_t.subclass(*args_, **kwargs_)
        else:
            return Version_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VersionMajor(self): return self.VersionMajor
    def set_VersionMajor(self, VersionMajor): self.VersionMajor = VersionMajor
    def get_VersionMinor(self): return self.VersionMinor
    def set_VersionMinor(self, VersionMinor): self.VersionMinor = VersionMinor
    def get_BuildMajor(self): return self.BuildMajor
    def set_BuildMajor(self, BuildMajor): self.BuildMajor = BuildMajor
    def get_BuildMinor(self): return self.BuildMinor
    def set_BuildMinor(self, BuildMinor): self.BuildMinor = BuildMinor
    def export(self, outfile, level, namespace_='tc2:', name_='Version_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Version_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Version_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Version_t'):
        if self.VersionMajor is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersionMajor>%s</%sVersionMajor>\n' % (namespace_, self.gds_format_string(quote_xml(self.VersionMajor).encode(ExternalEncoding), input_name='VersionMajor'), namespace_))
        if self.VersionMinor is not None:
            showIndent(outfile, level)
            outfile.write('<%sVersionMinor>%s</%sVersionMinor>\n' % (namespace_, self.gds_format_string(quote_xml(self.VersionMinor).encode(ExternalEncoding), input_name='VersionMinor'), namespace_))
        if self.BuildMajor is not None:
            showIndent(outfile, level)
            outfile.write('<%sBuildMajor>%s</%sBuildMajor>\n' % (namespace_, self.gds_format_string(quote_xml(self.BuildMajor).encode(ExternalEncoding), input_name='BuildMajor'), namespace_))
        if self.BuildMinor is not None:
            showIndent(outfile, level)
            outfile.write('<%sBuildMinor>%s</%sBuildMinor>\n' % (namespace_, self.gds_format_string(quote_xml(self.BuildMinor).encode(ExternalEncoding), input_name='BuildMinor'), namespace_))
    def hasContent_(self):
        if (
            self.VersionMajor is not None or
            self.VersionMinor is not None or
            self.BuildMajor is not None or
            self.BuildMinor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Version_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VersionMajor is not None:
            showIndent(outfile, level)
            outfile.write('VersionMajor=%s,\n' % quote_python(self.VersionMajor).encode(ExternalEncoding))
        if self.VersionMinor is not None:
            showIndent(outfile, level)
            outfile.write('VersionMinor=%s,\n' % quote_python(self.VersionMinor).encode(ExternalEncoding))
        if self.BuildMajor is not None:
            showIndent(outfile, level)
            outfile.write('BuildMajor=%s,\n' % quote_python(self.BuildMajor).encode(ExternalEncoding))
        if self.BuildMinor is not None:
            showIndent(outfile, level)
            outfile.write('BuildMinor=%s,\n' % quote_python(self.BuildMinor).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'VersionMajor':
            VersionMajor_ = child_.text
            VersionMajor_ = self.gds_validate_string(VersionMajor_, node, 'VersionMajor')
            self.VersionMajor = VersionMajor_
        elif nodeName_ == 'VersionMinor':
            VersionMinor_ = child_.text
            VersionMinor_ = self.gds_validate_string(VersionMinor_, node, 'VersionMinor')
            self.VersionMinor = VersionMinor_
        elif nodeName_ == 'BuildMajor':
            BuildMajor_ = child_.text
            BuildMajor_ = self.gds_validate_string(BuildMajor_, node, 'BuildMajor')
            self.BuildMajor = BuildMajor_
        elif nodeName_ == 'BuildMinor':
            BuildMinor_ = child_.text
            BuildMinor_ = self.gds_validate_string(BuildMinor_, node, 'BuildMinor')
            self.BuildMinor = BuildMinor_
# end class Version_t


class Training_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VirtualPartner=None, QuickWorkoutResults=None, Plan=None):
        self.VirtualPartner = _cast(bool, VirtualPartner)
        self.QuickWorkoutResults = QuickWorkoutResults
        self.Plan = Plan
    def factory(*args_, **kwargs_):
        if Training_t.subclass:
            return Training_t.subclass(*args_, **kwargs_)
        else:
            return Training_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QuickWorkoutResults(self): return self.QuickWorkoutResults
    def set_QuickWorkoutResults(self, QuickWorkoutResults): self.QuickWorkoutResults = QuickWorkoutResults
    def get_Plan(self): return self.Plan
    def set_Plan(self, Plan): self.Plan = Plan
    def get_VirtualPartner(self): return self.VirtualPartner
    def set_VirtualPartner(self, VirtualPartner): self.VirtualPartner = VirtualPartner
    def export(self, outfile, level, namespace_='tc2:', name_='Training_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Training_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Training_t'):
        if self.VirtualPartner is not None and 'VirtualPartner' not in already_processed:
            already_processed.append('VirtualPartner')
            outfile.write(' VirtualPartner="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.VirtualPartner)), input_name='VirtualPartner'))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Training_t'):
        if self.QuickWorkoutResults:
            self.QuickWorkoutResults.export(outfile, level, namespace_, name_='QuickWorkoutResults')
        if self.Plan:
            self.Plan.export(outfile, level, namespace_, name_='Plan')
    def hasContent_(self):
        if (
            self.QuickWorkoutResults is not None or
            self.Plan is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Training_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VirtualPartner is not None and 'VirtualPartner' not in already_processed:
            already_processed.append('VirtualPartner')
            showIndent(outfile, level)
            outfile.write('VirtualPartner = %s,\n' % (self.VirtualPartner,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.QuickWorkoutResults is not None:
            showIndent(outfile, level)
            outfile.write('QuickWorkoutResults=model_.QuickWorkout_t(\n')
            self.QuickWorkoutResults.exportLiteral(outfile, level, name_='QuickWorkoutResults')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Plan is not None:
            showIndent(outfile, level)
            outfile.write('Plan=model_.Plan_t(\n')
            self.Plan.exportLiteral(outfile, level, name_='Plan')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('VirtualPartner')
        if value is not None and 'VirtualPartner' not in already_processed:
            already_processed.append('VirtualPartner')
            if value in ('true', '1'):
                self.VirtualPartner = True
            elif value in ('false', '0'):
                self.VirtualPartner = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'QuickWorkoutResults': 
            obj_ = QuickWorkout_t.factory()
            obj_.build(child_)
            self.set_QuickWorkoutResults(obj_)
        elif nodeName_ == 'Plan': 
            obj_ = Plan_t.factory()
            obj_.build(child_)
            self.set_Plan(obj_)
# end class Training_t


class QuickWorkout_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TotalTimeSeconds=None, DistanceMeters=None):
        self.TotalTimeSeconds = TotalTimeSeconds
        self.DistanceMeters = DistanceMeters
    def factory(*args_, **kwargs_):
        if QuickWorkout_t.subclass:
            return QuickWorkout_t.subclass(*args_, **kwargs_)
        else:
            return QuickWorkout_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalTimeSeconds(self): return self.TotalTimeSeconds
    def set_TotalTimeSeconds(self, TotalTimeSeconds): self.TotalTimeSeconds = TotalTimeSeconds
    def get_DistanceMeters(self): return self.DistanceMeters
    def set_DistanceMeters(self, DistanceMeters): self.DistanceMeters = DistanceMeters
    def export(self, outfile, level, namespace_='tc2:', name_='QuickWorkout_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='QuickWorkout_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='QuickWorkout_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='QuickWorkout_t'):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalTimeSeconds>%s</%sTotalTimeSeconds>\n' % (namespace_, self.gds_format_string(quote_xml(self.TotalTimeSeconds).encode(ExternalEncoding), input_name='TotalTimeSeconds'), namespace_))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sDistanceMeters>%s</%sDistanceMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.DistanceMeters).encode(ExternalEncoding), input_name='DistanceMeters'), namespace_))
    def hasContent_(self):
        if (
            self.TotalTimeSeconds is not None or
            self.DistanceMeters is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuickWorkout_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('TotalTimeSeconds=%s,\n' % quote_python(self.TotalTimeSeconds).encode(ExternalEncoding))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('DistanceMeters=%s,\n' % quote_python(self.DistanceMeters).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'TotalTimeSeconds':
            TotalTimeSeconds_ = child_.text
            TotalTimeSeconds_ = self.gds_validate_string(TotalTimeSeconds_, node, 'TotalTimeSeconds')
            self.TotalTimeSeconds = TotalTimeSeconds_
        elif nodeName_ == 'DistanceMeters':
            DistanceMeters_ = child_.text
            DistanceMeters_ = self.gds_validate_string(DistanceMeters_, node, 'DistanceMeters')
            self.DistanceMeters = DistanceMeters_
# end class QuickWorkout_t


class Plan_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, IntervalWorkout=None, Name=None, Extensions=None):
        self.Type = _cast(None, Type)
        self.IntervalWorkout = _cast(bool, IntervalWorkout)
        self.Name = Name
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Plan_t.subclass:
            return Plan_t.subclass(*args_, **kwargs_)
        else:
            return Plan_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_TrainingType_t(self, value):
        # Validate type TrainingType_t, a restriction on Token_t.
        pass
    def get_IntervalWorkout(self): return self.IntervalWorkout
    def set_IntervalWorkout(self, IntervalWorkout): self.IntervalWorkout = IntervalWorkout
    def export(self, outfile, level, namespace_='tc2:', name_='Plan_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Plan_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Plan_t'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.IntervalWorkout is not None and 'IntervalWorkout' not in already_processed:
            already_processed.append('IntervalWorkout')
            outfile.write(' IntervalWorkout="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.IntervalWorkout)), input_name='IntervalWorkout'))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Plan_t'):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Plan_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.IntervalWorkout is not None and 'IntervalWorkout' not in already_processed:
            already_processed.append('IntervalWorkout')
            showIndent(outfile, level)
            outfile.write('IntervalWorkout = %s,\n' % (self.IntervalWorkout,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_TrainingType_t(self.Type)    # validate type TrainingType_t
        value = attrs.get('IntervalWorkout')
        if value is not None and 'IntervalWorkout' not in already_processed:
            already_processed.append('IntervalWorkout')
            if value in ('true', '1'):
                self.IntervalWorkout = True
            elif value in ('false', '0'):
                self.IntervalWorkout = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Plan_t


class ActivityLap_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartTime=None, TotalTimeSeconds=None, DistanceMeters=None, MaximumSpeed=None, Calories=None, AverageHeartRateBpm=None, MaximumHeartRateBpm=None, Intensity=None, Cadence=None, TriggerMethod=None, Track=None, Notes=None, Extensions=None):
        self.StartTime = _cast(None, StartTime)
        self.TotalTimeSeconds = TotalTimeSeconds
        self.DistanceMeters = DistanceMeters
        self.MaximumSpeed = MaximumSpeed
        self.Calories = Calories
        self.AverageHeartRateBpm = AverageHeartRateBpm
        self.MaximumHeartRateBpm = MaximumHeartRateBpm
        self.Intensity = Intensity
        self.Cadence = Cadence
        self.TriggerMethod = TriggerMethod
        if Track is None:
            self.Track = []
        else:
            self.Track = Track
        self.Notes = Notes
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if ActivityLap_t.subclass:
            return ActivityLap_t.subclass(*args_, **kwargs_)
        else:
            return ActivityLap_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalTimeSeconds(self): return self.TotalTimeSeconds
    def set_TotalTimeSeconds(self, TotalTimeSeconds): self.TotalTimeSeconds = TotalTimeSeconds
    def get_DistanceMeters(self): return self.DistanceMeters
    def set_DistanceMeters(self, DistanceMeters): self.DistanceMeters = DistanceMeters
    def get_MaximumSpeed(self): return self.MaximumSpeed
    def set_MaximumSpeed(self, MaximumSpeed): self.MaximumSpeed = MaximumSpeed
    def get_Calories(self): return self.Calories
    def set_Calories(self, Calories): self.Calories = Calories
    def get_AverageHeartRateBpm(self): return self.AverageHeartRateBpm
    def set_AverageHeartRateBpm(self, AverageHeartRateBpm): self.AverageHeartRateBpm = AverageHeartRateBpm
    def get_MaximumHeartRateBpm(self): return self.MaximumHeartRateBpm
    def set_MaximumHeartRateBpm(self, MaximumHeartRateBpm): self.MaximumHeartRateBpm = MaximumHeartRateBpm
    def get_Intensity(self): return self.Intensity
    def set_Intensity(self, Intensity): self.Intensity = Intensity
    def get_Cadence(self): return self.Cadence
    def set_Cadence(self, Cadence): self.Cadence = Cadence
    def get_TriggerMethod(self): return self.TriggerMethod
    def set_TriggerMethod(self, TriggerMethod): self.TriggerMethod = TriggerMethod
    def get_Track(self): return self.Track
    def set_Track(self, Track): self.Track = Track
    def add_Track(self, value): self.Track.append(value)
    def insert_Track(self, index, value): self.Track[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def export(self, outfile, level, namespace_='tc2:', name_='ActivityLap_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ActivityLap_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='ActivityLap_t'):
        if self.StartTime is not None and 'StartTime' not in already_processed:
            already_processed.append('StartTime')
            outfile.write(' StartTime=%s' % (self.gds_format_string(quote_attrib(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='ActivityLap_t'):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalTimeSeconds>%s</%sTotalTimeSeconds>\n' % (namespace_, self.gds_format_string(quote_xml(self.TotalTimeSeconds).encode(ExternalEncoding), input_name='TotalTimeSeconds'), namespace_))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sDistanceMeters>%s</%sDistanceMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.DistanceMeters).encode(ExternalEncoding), input_name='DistanceMeters'), namespace_))
        if self.MaximumSpeed is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaximumSpeed>%s</%sMaximumSpeed>\n' % (namespace_, self.gds_format_string(quote_xml(self.MaximumSpeed).encode(ExternalEncoding), input_name='MaximumSpeed'), namespace_))
        if self.Calories is not None:
            showIndent(outfile, level)
            outfile.write('<%sCalories>%s</%sCalories>\n' % (namespace_, self.gds_format_string(quote_xml(self.Calories).encode(ExternalEncoding), input_name='Calories'), namespace_))
        if self.AverageHeartRateBpm:
            self.AverageHeartRateBpm.export(outfile, level, namespace_, name_='AverageHeartRateBpm')
        if self.MaximumHeartRateBpm:
            self.MaximumHeartRateBpm.export(outfile, level, namespace_, name_='MaximumHeartRateBpm')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('<%sIntensity>%s</%sIntensity>\n' % (namespace_, self.gds_format_string(quote_xml(self.Intensity).encode(ExternalEncoding), input_name='Intensity'), namespace_))
        if self.Cadence:
            self.Cadence.export(outfile, level, namespace_, name_='Cadence')
        if self.TriggerMethod is not None:
            showIndent(outfile, level)
            outfile.write('<%sTriggerMethod>%s</%sTriggerMethod>\n' % (namespace_, self.gds_format_string(quote_xml(self.TriggerMethod).encode(ExternalEncoding), input_name='TriggerMethod'), namespace_))
        for Track_ in self.Track:
            Track_.export(outfile, level, namespace_, name_='Track')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.TotalTimeSeconds is not None or
            self.DistanceMeters is not None or
            self.MaximumSpeed is not None or
            self.Calories is not None or
            self.AverageHeartRateBpm is not None or
            self.MaximumHeartRateBpm is not None or
            self.Intensity is not None or
            self.Cadence is not None or
            self.TriggerMethod is not None or
            self.Track or
            self.Notes is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActivityLap_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StartTime is not None and 'StartTime' not in already_processed:
            already_processed.append('StartTime')
            showIndent(outfile, level)
            outfile.write('StartTime = "%s",\n' % (self.StartTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('TotalTimeSeconds=%s,\n' % quote_python(self.TotalTimeSeconds).encode(ExternalEncoding))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('DistanceMeters=%s,\n' % quote_python(self.DistanceMeters).encode(ExternalEncoding))
        if self.MaximumSpeed is not None:
            showIndent(outfile, level)
            outfile.write('MaximumSpeed=%s,\n' % quote_python(self.MaximumSpeed).encode(ExternalEncoding))
        if self.Calories is not None:
            showIndent(outfile, level)
            outfile.write('Calories=%s,\n' % quote_python(self.Calories).encode(ExternalEncoding))
        if self.AverageHeartRateBpm is not None:
            showIndent(outfile, level)
            outfile.write('AverageHeartRateBpm=model_.HeartRateInBeatsPerMinute_t(\n')
            self.AverageHeartRateBpm.exportLiteral(outfile, level, name_='AverageHeartRateBpm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MaximumHeartRateBpm is not None:
            showIndent(outfile, level)
            outfile.write('MaximumHeartRateBpm=model_.HeartRateInBeatsPerMinute_t(\n')
            self.MaximumHeartRateBpm.exportLiteral(outfile, level, name_='MaximumHeartRateBpm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('Intensity=%s,\n' % quote_python(self.Intensity).encode(ExternalEncoding))
        if self.Cadence is not None:
            showIndent(outfile, level)
            outfile.write('Cadence=model_.xsd_unsignedByte(\n')
            self.Cadence.exportLiteral(outfile, level, name_='Cadence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TriggerMethod is not None:
            showIndent(outfile, level)
            outfile.write('TriggerMethod=%s,\n' % quote_python(self.TriggerMethod).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Track=[\n')
        level += 1
        for Track_ in self.Track:
            showIndent(outfile, level)
            outfile.write('model_.Track_t(\n')
            Track_.exportLiteral(outfile, level, name_='Track_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('StartTime')
        if value is not None and 'StartTime' not in already_processed:
            already_processed.append('StartTime')
            self.StartTime = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'TotalTimeSeconds':
            TotalTimeSeconds_ = child_.text
            TotalTimeSeconds_ = self.gds_validate_string(TotalTimeSeconds_, node, 'TotalTimeSeconds')
            self.TotalTimeSeconds = TotalTimeSeconds_
        elif nodeName_ == 'DistanceMeters':
            DistanceMeters_ = child_.text
            DistanceMeters_ = self.gds_validate_string(DistanceMeters_, node, 'DistanceMeters')
            self.DistanceMeters = DistanceMeters_
        elif nodeName_ == 'MaximumSpeed':
            MaximumSpeed_ = child_.text
            MaximumSpeed_ = self.gds_validate_string(MaximumSpeed_, node, 'MaximumSpeed')
            self.MaximumSpeed = MaximumSpeed_
        elif nodeName_ == 'Calories':
            Calories_ = child_.text
            Calories_ = self.gds_validate_string(Calories_, node, 'Calories')
            self.Calories = Calories_
        elif nodeName_ == 'AverageHeartRateBpm': 
            obj_ = HeartRateInBeatsPerMinute_t.factory()
            obj_.build(child_)
            self.set_AverageHeartRateBpm(obj_)
        elif nodeName_ == 'MaximumHeartRateBpm': 
            obj_ = HeartRateInBeatsPerMinute_t.factory()
            obj_.build(child_)
            self.set_MaximumHeartRateBpm(obj_)
        elif nodeName_ == 'Intensity':
            Intensity_ = child_.text
            Intensity_ = re_.sub(STRING_CLEANUP_PAT, " ", Intensity_).strip()
            Intensity_ = self.gds_validate_string(Intensity_, node, 'Intensity')
            self.Intensity = Intensity_
        elif nodeName_ == 'Cadence': 
            obj_ = None
            self.set_Cadence(obj_)
        elif nodeName_ == 'TriggerMethod':
            TriggerMethod_ = child_.text
            TriggerMethod_ = re_.sub(STRING_CLEANUP_PAT, " ", TriggerMethod_).strip()
            TriggerMethod_ = self.gds_validate_string(TriggerMethod_, node, 'TriggerMethod')
            self.TriggerMethod = TriggerMethod_
        elif nodeName_ == 'Track': 
            obj_ = Track_t.factory()
            obj_.build(child_)
            self.Track.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class ActivityLap_t


class Track_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Trackpoint=None):
        if Trackpoint is None:
            self.Trackpoint = []
        else:
            self.Trackpoint = Trackpoint
    def factory(*args_, **kwargs_):
        if Track_t.subclass:
            return Track_t.subclass(*args_, **kwargs_)
        else:
            return Track_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trackpoint(self): return self.Trackpoint
    def set_Trackpoint(self, Trackpoint): self.Trackpoint = Trackpoint
    def add_Trackpoint(self, value): self.Trackpoint.append(value)
    def insert_Trackpoint(self, index, value): self.Trackpoint[index] = value
    def export(self, outfile, level, namespace_='tc2:', name_='Track_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Track_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Track_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Track_t'):
        for Trackpoint_ in self.Trackpoint:
            Trackpoint_.export(outfile, level, namespace_, name_='Trackpoint')
    def hasContent_(self):
        if (
            self.Trackpoint
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Track_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Trackpoint=[\n')
        level += 1
        for Trackpoint_ in self.Trackpoint:
            showIndent(outfile, level)
            outfile.write('model_.Trackpoint_t(\n')
            Trackpoint_.exportLiteral(outfile, level, name_='Trackpoint_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Trackpoint': 
            obj_ = Trackpoint_t.factory()
            obj_.build(child_)
            self.Trackpoint.append(obj_)
# end class Track_t


class Trackpoint_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Time=None, Position=None, AltitudeMeters=None, DistanceMeters=None, HeartRateBpm=None, Cadence=None, SensorState=None, Extensions=None):
        self.Time = Time
        self.Position = Position
        self.AltitudeMeters = AltitudeMeters
        self.DistanceMeters = DistanceMeters
        self.HeartRateBpm = HeartRateBpm
        self.Cadence = Cadence
        self.SensorState = SensorState
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Trackpoint_t.subclass:
            return Trackpoint_t.subclass(*args_, **kwargs_)
        else:
            return Trackpoint_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_AltitudeMeters(self): return self.AltitudeMeters
    def set_AltitudeMeters(self, AltitudeMeters): self.AltitudeMeters = AltitudeMeters
    def get_DistanceMeters(self): return self.DistanceMeters
    def set_DistanceMeters(self, DistanceMeters): self.DistanceMeters = DistanceMeters
    def get_HeartRateBpm(self): return self.HeartRateBpm
    def set_HeartRateBpm(self, HeartRateBpm): self.HeartRateBpm = HeartRateBpm
    def get_Cadence(self): return self.Cadence
    def set_Cadence(self, Cadence): self.Cadence = Cadence
    def get_SensorState(self): return self.SensorState
    def set_SensorState(self, SensorState): self.SensorState = SensorState
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='Trackpoint_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Trackpoint_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Trackpoint_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Trackpoint_t'):
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('<%sTime>%s</%sTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.Time).encode(ExternalEncoding), input_name='Time'), namespace_))
        if self.Position:
            self.Position.export(outfile, level, namespace_, name_='Position')
        if self.AltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sAltitudeMeters>%s</%sAltitudeMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.AltitudeMeters).encode(ExternalEncoding), input_name='AltitudeMeters'), namespace_))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sDistanceMeters>%s</%sDistanceMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.DistanceMeters).encode(ExternalEncoding), input_name='DistanceMeters'), namespace_))
        if self.HeartRateBpm:
            self.HeartRateBpm.export(outfile, level, namespace_, name_='HeartRateBpm')
        if self.Cadence:
            self.Cadence.export(outfile, level, namespace_, name_='Cadence')
        if self.SensorState is not None:
            showIndent(outfile, level)
            outfile.write('<%sSensorState>%s</%sSensorState>\n' % (namespace_, self.gds_format_string(quote_xml(self.SensorState).encode(ExternalEncoding), input_name='SensorState'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Time is not None or
            self.Position is not None or
            self.AltitudeMeters is not None or
            self.DistanceMeters is not None or
            self.HeartRateBpm is not None or
            self.Cadence is not None or
            self.SensorState is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Trackpoint_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=%s,\n' % quote_python(self.Time).encode(ExternalEncoding))
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.Position_t(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('AltitudeMeters=%s,\n' % quote_python(self.AltitudeMeters).encode(ExternalEncoding))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('DistanceMeters=%s,\n' % quote_python(self.DistanceMeters).encode(ExternalEncoding))
        if self.HeartRateBpm is not None:
            showIndent(outfile, level)
            outfile.write('HeartRateBpm=model_.HeartRateInBeatsPerMinute_t(\n')
            self.HeartRateBpm.exportLiteral(outfile, level, name_='HeartRateBpm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Cadence is not None:
            showIndent(outfile, level)
            outfile.write('Cadence=model_.xsd_unsignedByte(\n')
            self.Cadence.exportLiteral(outfile, level, name_='Cadence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorState is not None:
            showIndent(outfile, level)
            outfile.write('SensorState=%s,\n' % quote_python(self.SensorState).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
        elif nodeName_ == 'Position': 
            obj_ = Position_t.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'AltitudeMeters':
            AltitudeMeters_ = child_.text
            AltitudeMeters_ = self.gds_validate_string(AltitudeMeters_, node, 'AltitudeMeters')
            self.AltitudeMeters = AltitudeMeters_
        elif nodeName_ == 'DistanceMeters':
            DistanceMeters_ = child_.text
            DistanceMeters_ = self.gds_validate_string(DistanceMeters_, node, 'DistanceMeters')
            self.DistanceMeters = DistanceMeters_
        elif nodeName_ == 'HeartRateBpm': 
            obj_ = HeartRateInBeatsPerMinute_t.factory()
            obj_.build(child_)
            self.set_HeartRateBpm(obj_)
        elif nodeName_ == 'Cadence': 
            obj_ = None
            self.set_Cadence(obj_)
        elif nodeName_ == 'SensorState':
            SensorState_ = child_.text
            SensorState_ = re_.sub(STRING_CLEANUP_PAT, " ", SensorState_).strip()
            SensorState_ = self.gds_validate_string(SensorState_, node, 'SensorState')
            self.SensorState = SensorState_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Trackpoint_t


class Position_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LatitudeDegrees=None, LongitudeDegrees=None):
        self.LatitudeDegrees = LatitudeDegrees
        self.LongitudeDegrees = LongitudeDegrees
    def factory(*args_, **kwargs_):
        if Position_t.subclass:
            return Position_t.subclass(*args_, **kwargs_)
        else:
            return Position_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LatitudeDegrees(self): return self.LatitudeDegrees
    def set_LatitudeDegrees(self, LatitudeDegrees): self.LatitudeDegrees = LatitudeDegrees
    def get_LongitudeDegrees(self): return self.LongitudeDegrees
    def set_LongitudeDegrees(self, LongitudeDegrees): self.LongitudeDegrees = LongitudeDegrees
    def export(self, outfile, level, namespace_='tc2:', name_='Position_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Position_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Position_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Position_t'):
        if self.LatitudeDegrees is not None:
            showIndent(outfile, level)
            outfile.write('<%sLatitudeDegrees>%s</%sLatitudeDegrees>\n' % (namespace_, self.gds_format_double(self.LatitudeDegrees, input_name='LatitudeDegrees'), namespace_))
        if self.LongitudeDegrees is not None:
            showIndent(outfile, level)
            outfile.write('<%sLongitudeDegrees>%s</%sLongitudeDegrees>\n' % (namespace_, self.gds_format_double(self.LongitudeDegrees, input_name='LongitudeDegrees'), namespace_))
    def hasContent_(self):
        if (
            self.LatitudeDegrees is not None or
            self.LongitudeDegrees is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Position_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LatitudeDegrees is not None:
            showIndent(outfile, level)
            outfile.write('LatitudeDegrees=%e,\n' % self.LatitudeDegrees)
        if self.LongitudeDegrees is not None:
            showIndent(outfile, level)
            outfile.write('LongitudeDegrees=%e,\n' % self.LongitudeDegrees)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'LatitudeDegrees':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'LatitudeDegrees')
            self.LatitudeDegrees = fval_
        elif nodeName_ == 'LongitudeDegrees':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'LongitudeDegrees')
            self.LongitudeDegrees = fval_
# end class Position_t


class Workouts_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Running=None, Biking=None, Other=None, Extensions=None):
        self.Running = Running
        self.Biking = Biking
        self.Other = Other
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Workouts_t.subclass:
            return Workouts_t.subclass(*args_, **kwargs_)
        else:
            return Workouts_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Running(self): return self.Running
    def set_Running(self, Running): self.Running = Running
    def get_Biking(self): return self.Biking
    def set_Biking(self, Biking): self.Biking = Biking
    def get_Other(self): return self.Other
    def set_Other(self, Other): self.Other = Other
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='Workouts_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Workouts_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Workouts_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Workouts_t'):
        if self.Running:
            self.Running.export(outfile, level, namespace_, name_='Running', )
        if self.Biking:
            self.Biking.export(outfile, level, namespace_, name_='Biking', )
        if self.Other:
            self.Other.export(outfile, level, namespace_, name_='Other', )
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Running is not None or
            self.Biking is not None or
            self.Other is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Workouts_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Running is not None:
            showIndent(outfile, level)
            outfile.write('Running=model_.WorkoutFolder_t(\n')
            self.Running.exportLiteral(outfile, level, name_='Running')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Biking is not None:
            showIndent(outfile, level)
            outfile.write('Biking=model_.WorkoutFolder_t(\n')
            self.Biking.exportLiteral(outfile, level, name_='Biking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Other is not None:
            showIndent(outfile, level)
            outfile.write('Other=model_.WorkoutFolder_t(\n')
            self.Other.exportLiteral(outfile, level, name_='Other')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Running': 
            obj_ = WorkoutFolder_t.factory()
            obj_.build(child_)
            self.set_Running(obj_)
        elif nodeName_ == 'Biking': 
            obj_ = WorkoutFolder_t.factory()
            obj_.build(child_)
            self.set_Biking(obj_)
        elif nodeName_ == 'Other': 
            obj_ = WorkoutFolder_t.factory()
            obj_.build(child_)
            self.set_Other(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Workouts_t


class NameKeyReference_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.Id = Id
    def factory(*args_, **kwargs_):
        if NameKeyReference_t.subclass:
            return NameKeyReference_t.subclass(*args_, **kwargs_)
        else:
            return NameKeyReference_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='tc2:', name_='NameKeyReference_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='NameKeyReference_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='NameKeyReference_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='NameKeyReference_t'):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('<%sId>%s</%sId>\n' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_))
    def hasContent_(self):
        if (
            self.Id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameKeyReference_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = re_.sub(STRING_CLEANUP_PAT, " ", Id_).strip()
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
# end class NameKeyReference_t


class WorkoutFolder_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Folder=None, WorkoutNameRef=None, Extensions=None):
        self.Name = _cast(None, Name)
        if Folder is None:
            self.Folder = []
        else:
            self.Folder = Folder
        if WorkoutNameRef is None:
            self.WorkoutNameRef = []
        else:
            self.WorkoutNameRef = WorkoutNameRef
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if WorkoutFolder_t.subclass:
            return WorkoutFolder_t.subclass(*args_, **kwargs_)
        else:
            return WorkoutFolder_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Folder(self): return self.Folder
    def set_Folder(self, Folder): self.Folder = Folder
    def add_Folder(self, value): self.Folder.append(value)
    def insert_Folder(self, index, value): self.Folder[index] = value
    def get_WorkoutNameRef(self): return self.WorkoutNameRef
    def set_WorkoutNameRef(self, WorkoutNameRef): self.WorkoutNameRef = WorkoutNameRef
    def add_WorkoutNameRef(self, value): self.WorkoutNameRef.append(value)
    def insert_WorkoutNameRef(self, index, value): self.WorkoutNameRef[index] = value
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='tc2:', name_='WorkoutFolder_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='WorkoutFolder_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='WorkoutFolder_t'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='WorkoutFolder_t'):
        for Folder_ in self.Folder:
            Folder_.export(outfile, level, namespace_, name_='Folder')
        for WorkoutNameRef_ in self.WorkoutNameRef:
            WorkoutNameRef_.export(outfile, level, namespace_, name_='WorkoutNameRef')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Folder or
            self.WorkoutNameRef or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WorkoutFolder_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Folder=[\n')
        level += 1
        for Folder_ in self.Folder:
            showIndent(outfile, level)
            outfile.write('model_.WorkoutFolder_t(\n')
            Folder_.exportLiteral(outfile, level, name_='WorkoutFolder_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('WorkoutNameRef=[\n')
        level += 1
        for WorkoutNameRef_ in self.WorkoutNameRef:
            showIndent(outfile, level)
            outfile.write('model_.NameKeyReference_t(\n')
            WorkoutNameRef_.exportLiteral(outfile, level, name_='NameKeyReference_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Folder': 
            obj_ = WorkoutFolder_t.factory()
            obj_.build(child_)
            self.Folder.append(obj_)
        elif nodeName_ == 'WorkoutNameRef': 
            obj_ = NameKeyReference_t.factory()
            obj_.build(child_)
            self.WorkoutNameRef.append(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class WorkoutFolder_t


class Workout_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Sport=None, Name=None, Step=None, ScheduledOn=None, Notes=None, Creator=None, Extensions=None):
        self.Sport = _cast(None, Sport)
        self.Name = Name
        if Step is None:
            self.Step = []
        else:
            self.Step = Step
        if ScheduledOn is None:
            self.ScheduledOn = []
        else:
            self.ScheduledOn = ScheduledOn
        self.Notes = Notes
        self.Creator = Creator
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Workout_t.subclass:
            return Workout_t.subclass(*args_, **kwargs_)
        else:
            return Workout_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Step(self): return self.Step
    def set_Step(self, Step): self.Step = Step
    def add_Step(self, value): self.Step.append(value)
    def insert_Step(self, index, value): self.Step[index] = value
    def get_ScheduledOn(self): return self.ScheduledOn
    def set_ScheduledOn(self, ScheduledOn): self.ScheduledOn = ScheduledOn
    def add_ScheduledOn(self, value): self.ScheduledOn.append(value)
    def insert_ScheduledOn(self, index, value): self.ScheduledOn[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Creator(self): return self.Creator
    def set_Creator(self, Creator): self.Creator = Creator
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Sport(self): return self.Sport
    def set_Sport(self, Sport): self.Sport = Sport
    def validate_Sport_t(self, value):
        # Validate type Sport_t, a restriction on Token_t.
        pass
    def export(self, outfile, level, namespace_='tc2:', name_='Workout_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Workout_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Workout_t'):
        if self.Sport is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            outfile.write(' Sport=%s' % (quote_attrib(self.Sport), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Workout_t'):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        for Step_ in self.get_Step():
            Step_.export(outfile, level, namespace_, name_='Step')
        for ScheduledOn_ in self.ScheduledOn:
            showIndent(outfile, level)
            outfile.write('<%sScheduledOn>%s</%sScheduledOn>\n' % (namespace_, self.gds_format_string(quote_xml(ScheduledOn_).encode(ExternalEncoding), input_name='ScheduledOn'), namespace_))
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        #pr
        self.Creator.export(outfile, level, namespace_, name_='Creator')
        #Creator_.export(outfile, level, namespace_, name_='Creator')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Step or
            self.ScheduledOn or
            self.Notes is not None or
            self.Creator is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Workout_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Sport is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            showIndent(outfile, level)
            outfile.write('Sport = "%s",\n' % (self.Sport,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Step=[\n')
        level += 1
        for Step_ in self.Step:
            showIndent(outfile, level)
            outfile.write('model_.AbstractStep_t(\n')
            Step_.exportLiteral(outfile, level, name_='AbstractStep_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScheduledOn=[\n')
        level += 1
        for ScheduledOn_ in self.ScheduledOn:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ScheduledOn_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.AbstractSource_t is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSource_t=model_.AbstractSource_t(\n')
            self.AbstractSource_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Sport')
        if value is not None and 'Sport' not in already_processed:
            already_processed.append('Sport')
            self.Sport = value
            self.validate_Sport_t(self.Sport)    # validate type Sport_t
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Step': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Step> element')
            self.Step.append(obj_)
        elif nodeName_ == 'ScheduledOn':
            ScheduledOn_ = child_.text
            ScheduledOn_ = self.gds_validate_string(ScheduledOn_, node, 'ScheduledOn')
            self.ScheduledOn.append(ScheduledOn_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Creator': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Creator> element')
            self.set_Creator(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Workout_t


class AbstractStep_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StepId=None):
        self.StepId = StepId
    def factory(*args_, **kwargs_):
        if AbstractStep_t.subclass:
            return AbstractStep_t.subclass(*args_, **kwargs_)
        else:
            return AbstractStep_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StepId(self): return self.StepId
    def set_StepId(self, StepId): self.StepId = StepId
    def export(self, outfile, level, namespace_='tc2:', name_='AbstractStep_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='AbstractStep_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='AbstractStep_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='AbstractStep_t'):
        if self.StepId is not None:
            showIndent(outfile, level)
            outfile.write('<%sStepId>%s</%sStepId>\n' % (namespace_, self.gds_format_integer(self.StepId, input_name='StepId'), namespace_))
    def hasContent_(self):
        if (
            self.StepId is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractStep_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StepId is not None:
            showIndent(outfile, level)
            outfile.write('StepId=%d,\n' % self.StepId)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'StepId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepId')
            self.StepId = ival_
# end class AbstractStep_t


class Repeat_t(AbstractStep_t):
    subclass = None
    superclass = AbstractStep_t
    def __init__(self, StepId=None, Repetitions=None, Child=None):
        super(Repeat_t, self).__init__(StepId, )
        self.Repetitions = Repetitions
        if Child is None:
            self.Child = []
        else:
            self.Child = Child
    def factory(*args_, **kwargs_):
        if Repeat_t.subclass:
            return Repeat_t.subclass(*args_, **kwargs_)
        else:
            return Repeat_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Repetitions(self): return self.Repetitions
    def set_Repetitions(self, Repetitions): self.Repetitions = Repetitions
    def get_Child(self): return self.Child
    def set_Child(self, Child): self.Child = Child
    def add_Child(self, value): self.Child.append(value)
    def insert_Child(self, index, value): self.Child[index] = value
    def export(self, outfile, level, namespace_='tc2:', name_='Repeat_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Repeat_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Repeat_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Repeat_t'):
        super(Repeat_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Repeat_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Repeat_t'):
        super(Repeat_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Repetitions is not None:
            showIndent(outfile, level)
            outfile.write('<%sRepetitions>%s</%sRepetitions>\n' % (namespace_, self.gds_format_integer(self.Repetitions, input_name='Repetitions'), namespace_))
        for Child_ in self.get_Child():
            Child_.export(outfile, level, namespace_, name_='Child')
    def hasContent_(self):
        if (
            self.Repetitions is not None or
            self.Child or
            super(Repeat_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Repeat_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Repeat_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Repeat_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Repetitions is not None:
            showIndent(outfile, level)
            outfile.write('Repetitions=%d,\n' % self.Repetitions)
        showIndent(outfile, level)
        outfile.write('Child=[\n')
        level += 1
        for Child_ in self.Child:
            showIndent(outfile, level)
            outfile.write('model_.AbstractStep_t(\n')
            Child_.exportLiteral(outfile, level, name_='AbstractStep_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Repeat_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Repetitions':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Repetitions')
            self.Repetitions = ival_
        elif nodeName_ == 'Child': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Child> element')
            self.Child.append(obj_)
        super(Repeat_t, self).buildChildren(child_, node, nodeName_, True)
# end class Repeat_t


class Step_t(AbstractStep_t):
    subclass = None
    superclass = AbstractStep_t
    def __init__(self, StepId=None, Name=None, Duration=None, Intensity=None, Target=None):
        super(Step_t, self).__init__(StepId, )
        self.Name = Name
        self.Duration = Duration
        self.Intensity = Intensity
        self.Target = Target
    def factory(*args_, **kwargs_):
        if Step_t.subclass:
            return Step_t.subclass(*args_, **kwargs_)
        else:
            return Step_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Duration(self): return self.Duration
    def set_Duration(self, Duration): self.Duration = Duration
    def get_Intensity(self): return self.Intensity
    def set_Intensity(self, Intensity): self.Intensity = Intensity
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def export(self, outfile, level, namespace_='tc2:', name_='Step_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Step_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Step_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Step_t'):
        super(Step_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Step_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Step_t'):
        super(Step_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        Duration_.export(outfile, level, namespace_, name_='Duration')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('<%sIntensity>%s</%sIntensity>\n' % (namespace_, self.gds_format_string(quote_xml(self.Intensity).encode(ExternalEncoding), input_name='Intensity'), namespace_))
        Target_.export(outfile, level, namespace_, name_='Target')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Duration is not None or
            self.Intensity is not None or
            self.Target is not None or
            super(Step_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Step_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Step_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Step_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Duration_t is not None:
            showIndent(outfile, level)
            outfile.write('Duration_t=model_.Duration_t(\n')
            self.Duration_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('Intensity=%s,\n' % quote_python(self.Intensity).encode(ExternalEncoding))
        if self.Target_t is not None:
            showIndent(outfile, level)
            outfile.write('Target_t=model_.Target_t(\n')
            self.Target_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Step_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Duration': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Duration> element')
            self.set_Duration(obj_)
        elif nodeName_ == 'Intensity':
            Intensity_ = child_.text
            Intensity_ = re_.sub(STRING_CLEANUP_PAT, " ", Intensity_).strip()
            Intensity_ = self.gds_validate_string(Intensity_, node, 'Intensity')
            self.Intensity = Intensity_
        elif nodeName_ == 'Target': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Target> element')
            self.set_Target(obj_)
        super(Step_t, self).buildChildren(child_, node, nodeName_, True)
# end class Step_t


class Duration_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Duration_t.subclass:
            return Duration_t.subclass(*args_, **kwargs_)
        else:
            return Duration_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='Duration_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Duration_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Duration_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Duration_t'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Duration_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        pass
# end class Duration_t


class Target_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Target_t.subclass:
            return Target_t.subclass(*args_, **kwargs_)
        else:
            return Target_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='Target_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Target_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Target_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Target_t'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        pass
# end class Target_t


class Time_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, Seconds=None):
        super(Time_t, self).__init__()
        self.Seconds = Seconds
    def factory(*args_, **kwargs_):
        if Time_t.subclass:
            return Time_t.subclass(*args_, **kwargs_)
        else:
            return Time_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Seconds(self): return self.Seconds
    def set_Seconds(self, Seconds): self.Seconds = Seconds
    def export(self, outfile, level, namespace_='tc2:', name_='Time_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Time_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Time_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Time_t'):
        super(Time_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Time_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Time_t'):
        super(Time_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Seconds is not None:
            showIndent(outfile, level)
            outfile.write('<%sSeconds>%s</%sSeconds>\n' % (namespace_, self.gds_format_string(quote_xml(self.Seconds).encode(ExternalEncoding), input_name='Seconds'), namespace_))
    def hasContent_(self):
        if (
            self.Seconds is not None or
            super(Time_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Time_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Time_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Time_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Seconds is not None:
            showIndent(outfile, level)
            outfile.write('Seconds=%s,\n' % quote_python(self.Seconds).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Time_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Seconds':
            Seconds_ = child_.text
            Seconds_ = self.gds_validate_string(Seconds_, node, 'Seconds')
            self.Seconds = Seconds_
        super(Time_t, self).buildChildren(child_, node, nodeName_, True)
# end class Time_t


class Distance_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, Meters=None):
        super(Distance_t, self).__init__()
        self.Meters = Meters
    def factory(*args_, **kwargs_):
        if Distance_t.subclass:
            return Distance_t.subclass(*args_, **kwargs_)
        else:
            return Distance_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Meters(self): return self.Meters
    def set_Meters(self, Meters): self.Meters = Meters
    def export(self, outfile, level, namespace_='tc2:', name_='Distance_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Distance_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Distance_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Distance_t'):
        super(Distance_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Distance_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Distance_t'):
        super(Distance_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Meters is not None:
            showIndent(outfile, level)
            outfile.write('<%sMeters>%s</%sMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.Meters).encode(ExternalEncoding), input_name='Meters'), namespace_))
    def hasContent_(self):
        if (
            self.Meters is not None or
            super(Distance_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Distance_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Distance_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Distance_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Meters is not None:
            showIndent(outfile, level)
            outfile.write('Meters=%s,\n' % quote_python(self.Meters).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Distance_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Meters':
            Meters_ = child_.text
            Meters_ = self.gds_validate_string(Meters_, node, 'Meters')
            self.Meters = Meters_
        super(Distance_t, self).buildChildren(child_, node, nodeName_, True)
# end class Distance_t


class HeartRateAbove_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, HeartRate=None):
        super(HeartRateAbove_t, self).__init__()
        self.HeartRate = HeartRate
    def factory(*args_, **kwargs_):
        if HeartRateAbove_t.subclass:
            return HeartRateAbove_t.subclass(*args_, **kwargs_)
        else:
            return HeartRateAbove_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HeartRate(self): return self.HeartRate
    def set_HeartRate(self, HeartRate): self.HeartRate = HeartRate
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRateAbove_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRateAbove_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="HeartRateAbove_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRateAbove_t'):
        super(HeartRateAbove_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HeartRateAbove_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRateAbove_t'):
        super(HeartRateAbove_t, self).exportChildren(outfile, level, namespace_, name_)
        HeartRate_.export(outfile, level, namespace_, name_='HeartRate')
    def hasContent_(self):
        if (
            self.HeartRate is not None or
            super(HeartRateAbove_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRateAbove_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HeartRateAbove_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HeartRateAbove_t, self).exportLiteralChildren(outfile, level, name_)
        if self.HeartRateValue_t is not None:
            showIndent(outfile, level)
            outfile.write('HeartRateValue_t=model_.HeartRateValue_t(\n')
            self.HeartRateValue_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HeartRateAbove_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'HeartRate': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <HeartRate> element')
            self.set_HeartRate(obj_)
        super(HeartRateAbove_t, self).buildChildren(child_, node, nodeName_, True)
# end class HeartRateAbove_t


class HeartRateValue_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HeartRateValue_t.subclass:
            return HeartRateValue_t.subclass(*args_, **kwargs_)
        else:
            return HeartRateValue_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRateValue_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRateValue_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRateValue_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRateValue_t'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRateValue_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        pass
# end class HeartRateValue_t


class HeartRateBelow_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, HeartRate=None):
        super(HeartRateBelow_t, self).__init__()
        self.HeartRate = HeartRate
    def factory(*args_, **kwargs_):
        if HeartRateBelow_t.subclass:
            return HeartRateBelow_t.subclass(*args_, **kwargs_)
        else:
            return HeartRateBelow_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HeartRate(self): return self.HeartRate
    def set_HeartRate(self, HeartRate): self.HeartRate = HeartRate
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRateBelow_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRateBelow_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="HeartRateBelow_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRateBelow_t'):
        super(HeartRateBelow_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HeartRateBelow_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRateBelow_t'):
        super(HeartRateBelow_t, self).exportChildren(outfile, level, namespace_, name_)
        HeartRate_.export(outfile, level, namespace_, name_='HeartRate')
    def hasContent_(self):
        if (
            self.HeartRate is not None or
            super(HeartRateBelow_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRateBelow_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HeartRateBelow_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HeartRateBelow_t, self).exportLiteralChildren(outfile, level, name_)
        if self.HeartRateValue_t is not None:
            showIndent(outfile, level)
            outfile.write('HeartRateValue_t=model_.HeartRateValue_t(\n')
            self.HeartRateValue_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HeartRateBelow_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'HeartRate': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <HeartRate> element')
            self.set_HeartRate(obj_)
        super(HeartRateBelow_t, self).buildChildren(child_, node, nodeName_, True)
# end class HeartRateBelow_t


class CaloriesBurned_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, Calories=None):
        super(CaloriesBurned_t, self).__init__()
        self.Calories = Calories
    def factory(*args_, **kwargs_):
        if CaloriesBurned_t.subclass:
            return CaloriesBurned_t.subclass(*args_, **kwargs_)
        else:
            return CaloriesBurned_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Calories(self): return self.Calories
    def set_Calories(self, Calories): self.Calories = Calories
    def export(self, outfile, level, namespace_='tc2:', name_='CaloriesBurned_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CaloriesBurned_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="CaloriesBurned_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CaloriesBurned_t'):
        super(CaloriesBurned_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CaloriesBurned_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CaloriesBurned_t'):
        super(CaloriesBurned_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Calories is not None:
            showIndent(outfile, level)
            outfile.write('<%sCalories>%s</%sCalories>\n' % (namespace_, self.gds_format_string(quote_xml(self.Calories).encode(ExternalEncoding), input_name='Calories'), namespace_))
    def hasContent_(self):
        if (
            self.Calories is not None or
            super(CaloriesBurned_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CaloriesBurned_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CaloriesBurned_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CaloriesBurned_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Calories is not None:
            showIndent(outfile, level)
            outfile.write('Calories=%s,\n' % quote_python(self.Calories).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CaloriesBurned_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Calories':
            Calories_ = child_.text
            Calories_ = self.gds_validate_string(Calories_, node, 'Calories')
            self.Calories = Calories_
        super(CaloriesBurned_t, self).buildChildren(child_, node, nodeName_, True)
# end class CaloriesBurned_t


class UserInitiated_t(Duration_t):
    subclass = None
    superclass = Duration_t
    def __init__(self, valueOf_=None):
        super(UserInitiated_t, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UserInitiated_t.subclass:
            return UserInitiated_t.subclass(*args_, **kwargs_)
        else:
            return UserInitiated_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='UserInitiated_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='UserInitiated_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="UserInitiated_t"')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='UserInitiated_t'):
        super(UserInitiated_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UserInitiated_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='UserInitiated_t'):
        super(UserInitiated_t, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(UserInitiated_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserInitiated_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UserInitiated_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UserInitiated_t, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(UserInitiated_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        super(UserInitiated_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UserInitiated_t


class Speed_t(Target_t):
    subclass = None
    superclass = Target_t
    def __init__(self, SpeedZone=None):
        super(Speed_t, self).__init__()
        self.SpeedZone = SpeedZone
    def factory(*args_, **kwargs_):
        if Speed_t.subclass:
            return Speed_t.subclass(*args_, **kwargs_)
        else:
            return Speed_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpeedZone(self): return self.SpeedZone
    def set_SpeedZone(self, SpeedZone): self.SpeedZone = SpeedZone
    def export(self, outfile, level, namespace_='tc2:', name_='Speed_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Speed_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Speed_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Speed_t'):
        super(Speed_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Speed_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Speed_t'):
        super(Speed_t, self).exportChildren(outfile, level, namespace_, name_)
        SpeedZone_.export(outfile, level, namespace_, name_='SpeedZone')
    def hasContent_(self):
        if (
            self.SpeedZone is not None or
            super(Speed_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Speed_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Speed_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Speed_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Zone_t is not None:
            showIndent(outfile, level)
            outfile.write('Zone_t=model_.Zone_t(\n')
            self.Zone_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Speed_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'SpeedZone': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <SpeedZone> element')
            self.set_SpeedZone(obj_)
        super(Speed_t, self).buildChildren(child_, node, nodeName_, True)
# end class Speed_t


class HeartRate_t(Target_t):
    subclass = None
    superclass = Target_t
    def __init__(self, HeartRateZone=None):
        super(HeartRate_t, self).__init__()
        self.HeartRateZone = HeartRateZone
    def factory(*args_, **kwargs_):
        if HeartRate_t.subclass:
            return HeartRate_t.subclass(*args_, **kwargs_)
        else:
            return HeartRate_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HeartRateZone(self): return self.HeartRateZone
    def set_HeartRateZone(self, HeartRateZone): self.HeartRateZone = HeartRateZone
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRate_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRate_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="HeartRate_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRate_t'):
        super(HeartRate_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HeartRate_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRate_t'):
        super(HeartRate_t, self).exportChildren(outfile, level, namespace_, name_)
        HeartRateZone_.export(outfile, level, namespace_, name_='HeartRateZone')
    def hasContent_(self):
        if (
            self.HeartRateZone is not None or
            super(HeartRate_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRate_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HeartRate_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HeartRate_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Zone_t is not None:
            showIndent(outfile, level)
            outfile.write('Zone_t=model_.Zone_t(\n')
            self.Zone_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HeartRate_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'HeartRateZone': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <HeartRateZone> element')
            self.set_HeartRateZone(obj_)
        super(HeartRate_t, self).buildChildren(child_, node, nodeName_, True)
# end class HeartRate_t


class Cadence_t(Target_t):
    subclass = None
    superclass = Target_t
    def __init__(self, Low=None, High=None):
        super(Cadence_t, self).__init__()
        self.Low = Low
        self.High = High
    def factory(*args_, **kwargs_):
        if Cadence_t.subclass:
            return Cadence_t.subclass(*args_, **kwargs_)
        else:
            return Cadence_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Low(self): return self.Low
    def set_Low(self, Low): self.Low = Low
    def get_High(self): return self.High
    def set_High(self, High): self.High = High
    def export(self, outfile, level, namespace_='tc2:', name_='Cadence_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Cadence_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Cadence_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Cadence_t'):
        super(Cadence_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cadence_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Cadence_t'):
        super(Cadence_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Low is not None:
            showIndent(outfile, level)
            outfile.write('<%sLow>%s</%sLow>\n' % (namespace_, self.gds_format_string(quote_xml(self.Low).encode(ExternalEncoding), input_name='Low'), namespace_))
        if self.High is not None:
            showIndent(outfile, level)
            outfile.write('<%sHigh>%s</%sHigh>\n' % (namespace_, self.gds_format_string(quote_xml(self.High).encode(ExternalEncoding), input_name='High'), namespace_))
    def hasContent_(self):
        if (
            self.Low is not None or
            self.High is not None or
            super(Cadence_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cadence_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Cadence_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Cadence_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Low is not None:
            showIndent(outfile, level)
            outfile.write('Low=%s,\n' % quote_python(self.Low).encode(ExternalEncoding))
        if self.High is not None:
            showIndent(outfile, level)
            outfile.write('High=%s,\n' % quote_python(self.High).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Cadence_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Low':
            Low_ = child_.text
            Low_ = self.gds_validate_string(Low_, node, 'Low')
            self.Low = Low_
        elif nodeName_ == 'High':
            High_ = child_.text
            High_ = self.gds_validate_string(High_, node, 'High')
            self.High = High_
        super(Cadence_t, self).buildChildren(child_, node, nodeName_, True)
# end class Cadence_t


class None_t(Target_t):
    subclass = None
    superclass = Target_t
    def __init__(self, valueOf_=None):
        super(None_t, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if None_t.subclass:
            return None_t.subclass(*args_, **kwargs_)
        else:
            return None_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='None_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='None_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="None_t"')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='None_t'):
        super(None_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='None_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='None_t'):
        super(None_t, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(None_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='None_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(None_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(None_t, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(None_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        super(None_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class None_t


class Zone_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Zone_t.subclass:
            return Zone_t.subclass(*args_, **kwargs_)
        else:
            return Zone_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='Zone_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Zone_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Zone_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Zone_t'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Zone_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        pass
# end class Zone_t


class PredefinedSpeedZone_t(Zone_t):
    subclass = None
    superclass = Zone_t
    def __init__(self, Number=None):
        super(PredefinedSpeedZone_t, self).__init__()
        self.Number = Number
    def factory(*args_, **kwargs_):
        if PredefinedSpeedZone_t.subclass:
            return PredefinedSpeedZone_t.subclass(*args_, **kwargs_)
        else:
            return PredefinedSpeedZone_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def export(self, outfile, level, namespace_='tc2:', name_='PredefinedSpeedZone_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PredefinedSpeedZone_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="PredefinedSpeedZone_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='PredefinedSpeedZone_t'):
        super(PredefinedSpeedZone_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PredefinedSpeedZone_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='PredefinedSpeedZone_t'):
        super(PredefinedSpeedZone_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumber>%s</%sNumber>\n' % (namespace_, self.gds_format_integer(self.Number, input_name='Number'), namespace_))
    def hasContent_(self):
        if (
            self.Number is not None or
            super(PredefinedSpeedZone_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PredefinedSpeedZone_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PredefinedSpeedZone_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PredefinedSpeedZone_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('Number=%d,\n' % self.Number)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PredefinedSpeedZone_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Number':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Number')
            self.Number = ival_
        super(PredefinedSpeedZone_t, self).buildChildren(child_, node, nodeName_, True)
# end class PredefinedSpeedZone_t


class CustomSpeedZone_t(Zone_t):
    subclass = None
    superclass = Zone_t
    def __init__(self, ViewAs=None, LowInMetersPerSecond=None, HighInMetersPerSecond=None):
        super(CustomSpeedZone_t, self).__init__()
        self.ViewAs = ViewAs
        self.LowInMetersPerSecond = LowInMetersPerSecond
        self.HighInMetersPerSecond = HighInMetersPerSecond
    def factory(*args_, **kwargs_):
        if CustomSpeedZone_t.subclass:
            return CustomSpeedZone_t.subclass(*args_, **kwargs_)
        else:
            return CustomSpeedZone_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ViewAs(self): return self.ViewAs
    def set_ViewAs(self, ViewAs): self.ViewAs = ViewAs
    def get_LowInMetersPerSecond(self): return self.LowInMetersPerSecond
    def set_LowInMetersPerSecond(self, LowInMetersPerSecond): self.LowInMetersPerSecond = LowInMetersPerSecond
    def get_HighInMetersPerSecond(self): return self.HighInMetersPerSecond
    def set_HighInMetersPerSecond(self, HighInMetersPerSecond): self.HighInMetersPerSecond = HighInMetersPerSecond
    def export(self, outfile, level, namespace_='tc2:', name_='CustomSpeedZone_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CustomSpeedZone_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="CustomSpeedZone_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CustomSpeedZone_t'):
        super(CustomSpeedZone_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomSpeedZone_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CustomSpeedZone_t'):
        super(CustomSpeedZone_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.ViewAs is not None:
            showIndent(outfile, level)
            outfile.write('<%sViewAs>%s</%sViewAs>\n' % (namespace_, self.gds_format_string(quote_xml(self.ViewAs).encode(ExternalEncoding), input_name='ViewAs'), namespace_))
        if self.LowInMetersPerSecond is not None:
            showIndent(outfile, level)
            outfile.write('<%sLowInMetersPerSecond>%s</%sLowInMetersPerSecond>\n' % (namespace_, self.gds_format_double(self.LowInMetersPerSecond, input_name='LowInMetersPerSecond'), namespace_))
        if self.HighInMetersPerSecond is not None:
            showIndent(outfile, level)
            outfile.write('<%sHighInMetersPerSecond>%s</%sHighInMetersPerSecond>\n' % (namespace_, self.gds_format_double(self.HighInMetersPerSecond, input_name='HighInMetersPerSecond'), namespace_))
    def hasContent_(self):
        if (
            self.ViewAs is not None or
            self.LowInMetersPerSecond is not None or
            self.HighInMetersPerSecond is not None or
            super(CustomSpeedZone_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomSpeedZone_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomSpeedZone_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomSpeedZone_t, self).exportLiteralChildren(outfile, level, name_)
        if self.ViewAs is not None:
            showIndent(outfile, level)
            outfile.write('ViewAs=%s,\n' % quote_python(self.ViewAs).encode(ExternalEncoding))
        if self.LowInMetersPerSecond is not None:
            showIndent(outfile, level)
            outfile.write('LowInMetersPerSecond=%e,\n' % self.LowInMetersPerSecond)
        if self.HighInMetersPerSecond is not None:
            showIndent(outfile, level)
            outfile.write('HighInMetersPerSecond=%e,\n' % self.HighInMetersPerSecond)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomSpeedZone_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'ViewAs':
            ViewAs_ = child_.text
            ViewAs_ = re_.sub(STRING_CLEANUP_PAT, " ", ViewAs_).strip()
            ViewAs_ = self.gds_validate_string(ViewAs_, node, 'ViewAs')
            self.ViewAs = ViewAs_
        elif nodeName_ == 'LowInMetersPerSecond':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'LowInMetersPerSecond')
            self.LowInMetersPerSecond = fval_
        elif nodeName_ == 'HighInMetersPerSecond':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'HighInMetersPerSecond')
            self.HighInMetersPerSecond = fval_
        super(CustomSpeedZone_t, self).buildChildren(child_, node, nodeName_, True)
# end class CustomSpeedZone_t


class PredefinedHeartRateZone_t(Zone_t):
    subclass = None
    superclass = Zone_t
    def __init__(self, Number=None):
        super(PredefinedHeartRateZone_t, self).__init__()
        self.Number = Number
    def factory(*args_, **kwargs_):
        if PredefinedHeartRateZone_t.subclass:
            return PredefinedHeartRateZone_t.subclass(*args_, **kwargs_)
        else:
            return PredefinedHeartRateZone_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def export(self, outfile, level, namespace_='tc2:', name_='PredefinedHeartRateZone_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PredefinedHeartRateZone_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="PredefinedHeartRateZone_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='PredefinedHeartRateZone_t'):
        super(PredefinedHeartRateZone_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PredefinedHeartRateZone_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='PredefinedHeartRateZone_t'):
        super(PredefinedHeartRateZone_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumber>%s</%sNumber>\n' % (namespace_, self.gds_format_integer(self.Number, input_name='Number'), namespace_))
    def hasContent_(self):
        if (
            self.Number is not None or
            super(PredefinedHeartRateZone_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PredefinedHeartRateZone_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PredefinedHeartRateZone_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PredefinedHeartRateZone_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('Number=%d,\n' % self.Number)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PredefinedHeartRateZone_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Number':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Number')
            self.Number = ival_
        super(PredefinedHeartRateZone_t, self).buildChildren(child_, node, nodeName_, True)
# end class PredefinedHeartRateZone_t


class CustomHeartRateZone_t(Zone_t):
    subclass = None
    superclass = Zone_t
    def __init__(self, Low=None, High=None):
        super(CustomHeartRateZone_t, self).__init__()
        self.Low = Low
        self.High = High
    def factory(*args_, **kwargs_):
        if CustomHeartRateZone_t.subclass:
            return CustomHeartRateZone_t.subclass(*args_, **kwargs_)
        else:
            return CustomHeartRateZone_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Low(self): return self.Low
    def set_Low(self, Low): self.Low = Low
    def get_High(self): return self.High
    def set_High(self, High): self.High = High
    def export(self, outfile, level, namespace_='tc2:', name_='CustomHeartRateZone_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CustomHeartRateZone_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="CustomHeartRateZone_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CustomHeartRateZone_t'):
        super(CustomHeartRateZone_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomHeartRateZone_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CustomHeartRateZone_t'):
        super(CustomHeartRateZone_t, self).exportChildren(outfile, level, namespace_, name_)
        Low_.export(outfile, level, namespace_, name_='Low')
        High_.export(outfile, level, namespace_, name_='High')
    def hasContent_(self):
        if (
            self.Low is not None or
            self.High is not None or
            super(CustomHeartRateZone_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomHeartRateZone_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomHeartRateZone_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomHeartRateZone_t, self).exportLiteralChildren(outfile, level, name_)
        if self.HeartRateValue_t is not None:
            showIndent(outfile, level)
            outfile.write('HeartRateValue_t=model_.HeartRateValue_t(\n')
            self.HeartRateValue_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HeartRateValue_t is not None:
            showIndent(outfile, level)
            outfile.write('HeartRateValue_t=model_.HeartRateValue_t(\n')
            self.HeartRateValue_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomHeartRateZone_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Low': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Low> element')
            self.set_Low(obj_)
        elif nodeName_ == 'High': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <High> element')
            self.set_High(obj_)
        super(CustomHeartRateZone_t, self).buildChildren(child_, node, nodeName_, True)
# end class CustomHeartRateZone_t


class HeartRateInBeatsPerMinute_t(HeartRateValue_t):
    subclass = None
    superclass = HeartRateValue_t
    def __init__(self, Value=None):
        super(HeartRateInBeatsPerMinute_t, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if HeartRateInBeatsPerMinute_t.subclass:
            return HeartRateInBeatsPerMinute_t.subclass(*args_, **kwargs_)
        else:
            return HeartRateInBeatsPerMinute_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRateInBeatsPerMinute_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRateInBeatsPerMinute_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="HeartRateInBeatsPerMinute_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRateInBeatsPerMinute_t'):
        super(HeartRateInBeatsPerMinute_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HeartRateInBeatsPerMinute_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRateInBeatsPerMinute_t'):
        super(HeartRateInBeatsPerMinute_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Value:
            self.Value.export(outfile, level, namespace_, name_='Value', )
    def hasContent_(self):
        if (
            self.Value is not None or
            super(HeartRateInBeatsPerMinute_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRateInBeatsPerMinute_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HeartRateInBeatsPerMinute_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HeartRateInBeatsPerMinute_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.xsd_unsignedByte(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HeartRateInBeatsPerMinute_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Value': 
            obj_ = None
            self.set_Value(obj_)
        super(HeartRateInBeatsPerMinute_t, self).buildChildren(child_, node, nodeName_, True)
# end class HeartRateInBeatsPerMinute_t


class HeartRateAsPercentOfMax_t(HeartRateValue_t):
    subclass = None
    superclass = HeartRateValue_t
    def __init__(self, Value=None):
        super(HeartRateAsPercentOfMax_t, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if HeartRateAsPercentOfMax_t.subclass:
            return HeartRateAsPercentOfMax_t.subclass(*args_, **kwargs_)
        else:
            return HeartRateAsPercentOfMax_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='tc2:', name_='HeartRateAsPercentOfMax_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HeartRateAsPercentOfMax_t')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="HeartRateAsPercentOfMax_t"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='HeartRateAsPercentOfMax_t'):
        super(HeartRateAsPercentOfMax_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HeartRateAsPercentOfMax_t')
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='HeartRateAsPercentOfMax_t'):
        super(HeartRateAsPercentOfMax_t, self).exportChildren(outfile, level, namespace_, name_)
        if self.Value:
            self.Value.export(outfile, level, namespace_, name_='Value', )
    def hasContent_(self):
        if (
            self.Value is not None or
            super(HeartRateAsPercentOfMax_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeartRateAsPercentOfMax_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HeartRateAsPercentOfMax_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HeartRateAsPercentOfMax_t, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.xsd_unsignedByte(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HeartRateAsPercentOfMax_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Value': 
            obj_ = None
            self.set_Value(obj_)
        super(HeartRateAsPercentOfMax_t, self).buildChildren(child_, node, nodeName_, True)
# end class HeartRateAsPercentOfMax_t


class Courses_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CourseFolder=None, Extensions=None):
        self.CourseFolder = CourseFolder
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Courses_t.subclass:
            return Courses_t.subclass(*args_, **kwargs_)
        else:
            return Courses_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CourseFolder(self): return self.CourseFolder
    def set_CourseFolder(self, CourseFolder): self.CourseFolder = CourseFolder
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='Courses_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Courses_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Courses_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Courses_t'):
        if self.CourseFolder:
            self.CourseFolder.export(outfile, level, namespace_, name_='CourseFolder', )
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.CourseFolder is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Courses_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CourseFolder is not None:
            showIndent(outfile, level)
            outfile.write('CourseFolder=model_.CourseFolder_t(\n')
            self.CourseFolder.exportLiteral(outfile, level, name_='CourseFolder')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'CourseFolder': 
            obj_ = CourseFolder_t.factory()
            obj_.build(child_)
            self.set_CourseFolder(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Courses_t


class CourseFolder_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Folder=None, CourseNameRef=None, Notes=None, Extensions=None):
        self.Name = _cast(None, Name)
        if Folder is None:
            self.Folder = []
        else:
            self.Folder = Folder
        if CourseNameRef is None:
            self.CourseNameRef = []
        else:
            self.CourseNameRef = CourseNameRef
        self.Notes = Notes
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if CourseFolder_t.subclass:
            return CourseFolder_t.subclass(*args_, **kwargs_)
        else:
            return CourseFolder_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Folder(self): return self.Folder
    def set_Folder(self, Folder): self.Folder = Folder
    def add_Folder(self, value): self.Folder.append(value)
    def insert_Folder(self, index, value): self.Folder[index] = value
    def get_CourseNameRef(self): return self.CourseNameRef
    def set_CourseNameRef(self, CourseNameRef): self.CourseNameRef = CourseNameRef
    def add_CourseNameRef(self, value): self.CourseNameRef.append(value)
    def insert_CourseNameRef(self, index, value): self.CourseNameRef[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='tc2:', name_='CourseFolder_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CourseFolder_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CourseFolder_t'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CourseFolder_t'):
        for Folder_ in self.Folder:
            Folder_.export(outfile, level, namespace_, name_='Folder')
        for CourseNameRef_ in self.CourseNameRef:
            CourseNameRef_.export(outfile, level, namespace_, name_='CourseNameRef')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Folder or
            self.CourseNameRef or
            self.Notes is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseFolder_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Folder=[\n')
        level += 1
        for Folder_ in self.Folder:
            showIndent(outfile, level)
            outfile.write('model_.CourseFolder_t(\n')
            Folder_.exportLiteral(outfile, level, name_='CourseFolder_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CourseNameRef=[\n')
        level += 1
        for CourseNameRef_ in self.CourseNameRef:
            showIndent(outfile, level)
            outfile.write('model_.NameKeyReference_t(\n')
            CourseNameRef_.exportLiteral(outfile, level, name_='NameKeyReference_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Folder': 
            obj_ = CourseFolder_t.factory()
            obj_.build(child_)
            self.Folder.append(obj_)
        elif nodeName_ == 'CourseNameRef': 
            obj_ = NameKeyReference_t.factory()
            obj_.build(child_)
            self.CourseNameRef.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class CourseFolder_t


class Course_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Lap=None, Track=None, Notes=None, CoursePoint=None, Creator=None, Extensions=None):
        self.Name = Name
        if Lap is None:
            self.Lap = []
        else:
            self.Lap = Lap
        if Track is None:
            self.Track = []
        else:
            self.Track = Track
        self.Notes = Notes
        if CoursePoint is None:
            self.CoursePoint = []
        else:
            self.CoursePoint = CoursePoint
        self.Creator = Creator
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if Course_t.subclass:
            return Course_t.subclass(*args_, **kwargs_)
        else:
            return Course_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Lap(self): return self.Lap
    def set_Lap(self, Lap): self.Lap = Lap
    def add_Lap(self, value): self.Lap.append(value)
    def insert_Lap(self, index, value): self.Lap[index] = value
    def get_Track(self): return self.Track
    def set_Track(self, Track): self.Track = Track
    def add_Track(self, value): self.Track.append(value)
    def insert_Track(self, index, value): self.Track[index] = value
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_CoursePoint(self): return self.CoursePoint
    def set_CoursePoint(self, CoursePoint): self.CoursePoint = CoursePoint
    def add_CoursePoint(self, value): self.CoursePoint.append(value)
    def insert_CoursePoint(self, index, value): self.CoursePoint[index] = value
    def get_Creator(self): return self.Creator
    def set_Creator(self, Creator): self.Creator = Creator
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='Course_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Course_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Course_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Course_t'):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        for Lap_ in self.Lap:
            Lap_.export(outfile, level, namespace_, name_='Lap')
        for Track_ in self.Track:
            Track_.export(outfile, level, namespace_, name_='Track')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        for CoursePoint_ in self.CoursePoint:
            CoursePoint_.export(outfile, level, namespace_, name_='CoursePoint')
        # pr
        self.Creator.export(outfile, level, namespace_, name_='Creator')
        #Creator_.export(outfile, level, namespace_, name_='Creator')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Lap or
            self.Track or
            self.Notes is not None or
            self.CoursePoint or
            self.Creator is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Course_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Lap=[\n')
        level += 1
        for Lap_ in self.Lap:
            showIndent(outfile, level)
            outfile.write('model_.CourseLap_t(\n')
            Lap_.exportLiteral(outfile, level, name_='CourseLap_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Track=[\n')
        level += 1
        for Track_ in self.Track:
            showIndent(outfile, level)
            outfile.write('model_.Track_t(\n')
            Track_.exportLiteral(outfile, level, name_='Track_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CoursePoint=[\n')
        level += 1
        for CoursePoint_ in self.CoursePoint:
            showIndent(outfile, level)
            outfile.write('model_.CoursePoint_t(\n')
            CoursePoint_.exportLiteral(outfile, level, name_='CoursePoint_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AbstractSource_t is not None:
            showIndent(outfile, level)
            outfile.write('AbstractSource_t=model_.AbstractSource_t(\n')
            self.AbstractSource_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Lap': 
            obj_ = CourseLap_t.factory()
            obj_.build(child_)
            self.Lap.append(obj_)
        elif nodeName_ == 'Track': 
            obj_ = Track_t.factory()
            obj_.build(child_)
            self.Track.append(obj_)
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'CoursePoint': 
            obj_ = CoursePoint_t.factory()
            obj_.build(child_)
            self.CoursePoint.append(obj_)
        elif nodeName_ == 'Creator': 
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Creator> element')
            self.set_Creator(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class Course_t


class CourseLap_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TotalTimeSeconds=None, DistanceMeters=None, BeginPosition=None, BeginAltitudeMeters=None, EndPosition=None, EndAltitudeMeters=None, AverageHeartRateBpm=None, MaximumHeartRateBpm=None, Intensity=None, Cadence=None, Extensions=None):
        self.TotalTimeSeconds = TotalTimeSeconds
        self.DistanceMeters = DistanceMeters
        self.BeginPosition = BeginPosition
        self.BeginAltitudeMeters = BeginAltitudeMeters
        self.EndPosition = EndPosition
        self.EndAltitudeMeters = EndAltitudeMeters
        self.AverageHeartRateBpm = AverageHeartRateBpm
        self.MaximumHeartRateBpm = MaximumHeartRateBpm
        self.Intensity = Intensity
        self.Cadence = Cadence
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if CourseLap_t.subclass:
            return CourseLap_t.subclass(*args_, **kwargs_)
        else:
            return CourseLap_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalTimeSeconds(self): return self.TotalTimeSeconds
    def set_TotalTimeSeconds(self, TotalTimeSeconds): self.TotalTimeSeconds = TotalTimeSeconds
    def get_DistanceMeters(self): return self.DistanceMeters
    def set_DistanceMeters(self, DistanceMeters): self.DistanceMeters = DistanceMeters
    def get_BeginPosition(self): return self.BeginPosition
    def set_BeginPosition(self, BeginPosition): self.BeginPosition = BeginPosition
    def get_BeginAltitudeMeters(self): return self.BeginAltitudeMeters
    def set_BeginAltitudeMeters(self, BeginAltitudeMeters): self.BeginAltitudeMeters = BeginAltitudeMeters
    def get_EndPosition(self): return self.EndPosition
    def set_EndPosition(self, EndPosition): self.EndPosition = EndPosition
    def get_EndAltitudeMeters(self): return self.EndAltitudeMeters
    def set_EndAltitudeMeters(self, EndAltitudeMeters): self.EndAltitudeMeters = EndAltitudeMeters
    def get_AverageHeartRateBpm(self): return self.AverageHeartRateBpm
    def set_AverageHeartRateBpm(self, AverageHeartRateBpm): self.AverageHeartRateBpm = AverageHeartRateBpm
    def get_MaximumHeartRateBpm(self): return self.MaximumHeartRateBpm
    def set_MaximumHeartRateBpm(self, MaximumHeartRateBpm): self.MaximumHeartRateBpm = MaximumHeartRateBpm
    def get_Intensity(self): return self.Intensity
    def set_Intensity(self, Intensity): self.Intensity = Intensity
    def get_Cadence(self): return self.Cadence
    def set_Cadence(self, Cadence): self.Cadence = Cadence
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='CourseLap_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CourseLap_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CourseLap_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CourseLap_t'):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('<%sTotalTimeSeconds>%s</%sTotalTimeSeconds>\n' % (namespace_, self.gds_format_string(quote_xml(self.TotalTimeSeconds).encode(ExternalEncoding), input_name='TotalTimeSeconds'), namespace_))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sDistanceMeters>%s</%sDistanceMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.DistanceMeters).encode(ExternalEncoding), input_name='DistanceMeters'), namespace_))
        if self.BeginPosition:
            self.BeginPosition.export(outfile, level, namespace_, name_='BeginPosition')
        if self.BeginAltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sBeginAltitudeMeters>%s</%sBeginAltitudeMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.BeginAltitudeMeters).encode(ExternalEncoding), input_name='BeginAltitudeMeters'), namespace_))
        if self.EndPosition:
            self.EndPosition.export(outfile, level, namespace_, name_='EndPosition')
        if self.EndAltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndAltitudeMeters>%s</%sEndAltitudeMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndAltitudeMeters).encode(ExternalEncoding), input_name='EndAltitudeMeters'), namespace_))
        if self.AverageHeartRateBpm:
            self.AverageHeartRateBpm.export(outfile, level, namespace_, name_='AverageHeartRateBpm')
        if self.MaximumHeartRateBpm:
            self.MaximumHeartRateBpm.export(outfile, level, namespace_, name_='MaximumHeartRateBpm')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('<%sIntensity>%s</%sIntensity>\n' % (namespace_, self.gds_format_string(quote_xml(self.Intensity).encode(ExternalEncoding), input_name='Intensity'), namespace_))
        if self.Cadence:
            self.Cadence.export(outfile, level, namespace_, name_='Cadence')
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.TotalTimeSeconds is not None or
            self.DistanceMeters is not None or
            self.BeginPosition is not None or
            self.BeginAltitudeMeters is not None or
            self.EndPosition is not None or
            self.EndAltitudeMeters is not None or
            self.AverageHeartRateBpm is not None or
            self.MaximumHeartRateBpm is not None or
            self.Intensity is not None or
            self.Cadence is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CourseLap_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TotalTimeSeconds is not None:
            showIndent(outfile, level)
            outfile.write('TotalTimeSeconds=%s,\n' % quote_python(self.TotalTimeSeconds).encode(ExternalEncoding))
        if self.DistanceMeters is not None:
            showIndent(outfile, level)
            outfile.write('DistanceMeters=%s,\n' % quote_python(self.DistanceMeters).encode(ExternalEncoding))
        if self.BeginPosition is not None:
            showIndent(outfile, level)
            outfile.write('BeginPosition=model_.Position_t(\n')
            self.BeginPosition.exportLiteral(outfile, level, name_='BeginPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BeginAltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('BeginAltitudeMeters=%s,\n' % quote_python(self.BeginAltitudeMeters).encode(ExternalEncoding))
        if self.EndPosition is not None:
            showIndent(outfile, level)
            outfile.write('EndPosition=model_.Position_t(\n')
            self.EndPosition.exportLiteral(outfile, level, name_='EndPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndAltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('EndAltitudeMeters=%s,\n' % quote_python(self.EndAltitudeMeters).encode(ExternalEncoding))
        if self.AverageHeartRateBpm is not None:
            showIndent(outfile, level)
            outfile.write('AverageHeartRateBpm=model_.HeartRateInBeatsPerMinute_t(\n')
            self.AverageHeartRateBpm.exportLiteral(outfile, level, name_='AverageHeartRateBpm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MaximumHeartRateBpm is not None:
            showIndent(outfile, level)
            outfile.write('MaximumHeartRateBpm=model_.HeartRateInBeatsPerMinute_t(\n')
            self.MaximumHeartRateBpm.exportLiteral(outfile, level, name_='MaximumHeartRateBpm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Intensity is not None:
            showIndent(outfile, level)
            outfile.write('Intensity=%s,\n' % quote_python(self.Intensity).encode(ExternalEncoding))
        if self.Cadence is not None:
            showIndent(outfile, level)
            outfile.write('Cadence=model_.xsd_unsignedByte(\n')
            self.Cadence.exportLiteral(outfile, level, name_='Cadence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'TotalTimeSeconds':
            TotalTimeSeconds_ = child_.text
            TotalTimeSeconds_ = self.gds_validate_string(TotalTimeSeconds_, node, 'TotalTimeSeconds')
            self.TotalTimeSeconds = TotalTimeSeconds_
        elif nodeName_ == 'DistanceMeters':
            DistanceMeters_ = child_.text
            DistanceMeters_ = self.gds_validate_string(DistanceMeters_, node, 'DistanceMeters')
            self.DistanceMeters = DistanceMeters_
        elif nodeName_ == 'BeginPosition': 
            obj_ = Position_t.factory()
            obj_.build(child_)
            self.set_BeginPosition(obj_)
        elif nodeName_ == 'BeginAltitudeMeters':
            BeginAltitudeMeters_ = child_.text
            BeginAltitudeMeters_ = self.gds_validate_string(BeginAltitudeMeters_, node, 'BeginAltitudeMeters')
            self.BeginAltitudeMeters = BeginAltitudeMeters_
        elif nodeName_ == 'EndPosition': 
            obj_ = Position_t.factory()
            obj_.build(child_)
            self.set_EndPosition(obj_)
        elif nodeName_ == 'EndAltitudeMeters':
            EndAltitudeMeters_ = child_.text
            EndAltitudeMeters_ = self.gds_validate_string(EndAltitudeMeters_, node, 'EndAltitudeMeters')
            self.EndAltitudeMeters = EndAltitudeMeters_
        elif nodeName_ == 'AverageHeartRateBpm': 
            obj_ = HeartRateInBeatsPerMinute_t.factory()
            obj_.build(child_)
            self.set_AverageHeartRateBpm(obj_)
        elif nodeName_ == 'MaximumHeartRateBpm': 
            obj_ = HeartRateInBeatsPerMinute_t.factory()
            obj_.build(child_)
            self.set_MaximumHeartRateBpm(obj_)
        elif nodeName_ == 'Intensity':
            Intensity_ = child_.text
            Intensity_ = re_.sub(STRING_CLEANUP_PAT, " ", Intensity_).strip()
            Intensity_ = self.gds_validate_string(Intensity_, node, 'Intensity')
            self.Intensity = Intensity_
        elif nodeName_ == 'Cadence': 
            obj_ = None
            self.set_Cadence(obj_)
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class CourseLap_t


class CoursePoint_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Time=None, Position=None, AltitudeMeters=None, PointType=None, Notes=None, Extensions=None):
        self.Name = Name
        self.Time = Time
        self.Position = Position
        self.AltitudeMeters = AltitudeMeters
        self.PointType = PointType
        self.Notes = Notes
        self.Extensions = Extensions
    def factory(*args_, **kwargs_):
        if CoursePoint_t.subclass:
            return CoursePoint_t.subclass(*args_, **kwargs_)
        else:
            return CoursePoint_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_AltitudeMeters(self): return self.AltitudeMeters
    def set_AltitudeMeters(self, AltitudeMeters): self.AltitudeMeters = AltitudeMeters
    def get_PointType(self): return self.PointType
    def set_PointType(self, PointType): self.PointType = PointType
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Extensions(self): return self.Extensions
    def set_Extensions(self, Extensions): self.Extensions = Extensions
    def export(self, outfile, level, namespace_='tc2:', name_='CoursePoint_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CoursePoint_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='CoursePoint_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='CoursePoint_t'):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('<%sTime>%s</%sTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.Time).encode(ExternalEncoding), input_name='Time'), namespace_))
        if self.Position:
            self.Position.export(outfile, level, namespace_, name_='Position', )
        if self.AltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('<%sAltitudeMeters>%s</%sAltitudeMeters>\n' % (namespace_, self.gds_format_string(quote_xml(self.AltitudeMeters).encode(ExternalEncoding), input_name='AltitudeMeters'), namespace_))
        if self.PointType is not None:
            showIndent(outfile, level)
            outfile.write('<%sPointType>%s</%sPointType>\n' % (namespace_, self.gds_format_string(quote_xml(self.PointType).encode(ExternalEncoding), input_name='PointType'), namespace_))
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('<%sNotes>%s</%sNotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_))
        if self.Extensions:
            self.Extensions.export(outfile, level, namespace_, name_='Extensions')
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Time is not None or
            self.Position is not None or
            self.AltitudeMeters is not None or
            self.PointType is not None or
            self.Notes is not None or
            self.Extensions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoursePoint_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=%s,\n' % quote_python(self.Time).encode(ExternalEncoding))
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.Position_t(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AltitudeMeters is not None:
            showIndent(outfile, level)
            outfile.write('AltitudeMeters=%s,\n' % quote_python(self.AltitudeMeters).encode(ExternalEncoding))
        if self.PointType is not None:
            showIndent(outfile, level)
            outfile.write('PointType=%s,\n' % quote_python(self.PointType).encode(ExternalEncoding))
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Extensions is not None:
            showIndent(outfile, level)
            outfile.write('Extensions=model_.Extensions_t(\n')
            self.Extensions.exportLiteral(outfile, level, name_='Extensions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = re_.sub(STRING_CLEANUP_PAT, " ", Name_).strip()
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
        elif nodeName_ == 'Position': 
            obj_ = Position_t.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'AltitudeMeters':
            AltitudeMeters_ = child_.text
            AltitudeMeters_ = self.gds_validate_string(AltitudeMeters_, node, 'AltitudeMeters')
            self.AltitudeMeters = AltitudeMeters_
        elif nodeName_ == 'PointType':
            PointType_ = child_.text
            PointType_ = re_.sub(STRING_CLEANUP_PAT, " ", PointType_).strip()
            PointType_ = self.gds_validate_string(PointType_, node, 'PointType')
            self.PointType = PointType_
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Extensions': 
            obj_ = Extensions_t.factory()
            obj_.build(child_)
            self.set_Extensions(obj_)
# end class CoursePoint_t


class Extensions_t(GeneratedsSuper):
    """You can extend Training Center by adding your own elements from
    another schema here."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Extensions_t.subclass:
            return Extensions_t.subclass(*args_, **kwargs_)
        else:
            return Extensions_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tc2:', name_='Extensions_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Extensions_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tc2:', name_='Extensions_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='tc2:', name_='Extensions_t'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Extensions_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, from_subclass=False):
        pass
# end class Extensions_t


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrainingCenterDatabase'
        rootClass = TrainingCenterDatabase_t
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    #doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
    #    namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrainingCenterDatabase'
        rootClass = TrainingCenterDatabase_t
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="TrainingCenterDatabase",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrainingCenterDatabase'
        rootClass = TrainingCenterDatabase_t
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from garmin import *\n\n')
    sys.stdout.write('import garmin as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractSource_t",
    "AbstractStep_t",
    "ActivityLap_t",
    "ActivityList_t",
    "ActivityReference_t",
    "Activity_t",
    "Application_t",
    "Build_t",
    "Cadence_t",
    "CaloriesBurned_t",
    "CourseFolder_t",
    "CourseLap_t",
    "CourseList_t",
    "CoursePoint_t",
    "Course_t",
    "Courses_t",
    "CustomHeartRateZone_t",
    "CustomSpeedZone_t",
    "Device_t",
    "Distance_t",
    "Duration_t",
    "Extensions_t",
    "FirstSport_t",
    "Folders_t",
    "HeartRateAbove_t",
    "HeartRateAsPercentOfMax_t",
    "HeartRateBelow_t",
    "HeartRateInBeatsPerMinute_t",
    "HeartRateValue_t",
    "HeartRate_t",
    "HistoryFolder_t",
    "History_t",
    "MultiSportFolder_t",
    "MultiSportSession_t",
    "NameKeyReference_t",
    "NextSport_t",
    "None_t",
    "Plan_t",
    "Position_t",
    "PredefinedHeartRateZone_t",
    "PredefinedSpeedZone_t",
    "QuickWorkout_t",
    "Repeat_t",
    "Speed_t",
    "Step_t",
    "Target_t",
    "Time_t",
    "Track_t",
    "Trackpoint_t",
    "TrainingCenterDatabase_t",
    "Training_t",
    "UserInitiated_t",
    "Version_t",
    "Week_t",
    "WorkoutFolder_t",
    "WorkoutList_t",
    "Workout_t",
    "Workouts_t",
    "Zone_t"
    ]
